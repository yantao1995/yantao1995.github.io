{"meta":{"title":"Record life","subtitle":"blog","description":null,"author":"Tany","url":"https://yantao1995.github.io","root":"/"},"pages":[{"title":"Untitled","date":"2019-09-21T03:07:15.000Z","updated":"2019-09-21T03:07:15.023Z","comments":true,"path":"Untitled/index-1.html","permalink":"https://yantao1995.github.io/Untitled/index-1.html","excerpt":"","text":""},{"title":"Untitled","date":"2019-09-21T03:05:15.000Z","updated":"2019-09-21T03:05:15.026Z","comments":true,"path":"Untitled/index.html","permalink":"https://yantao1995.github.io/Untitled/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-07T07:39:54.840Z","updated":"2019-09-21T03:18:23.286Z","comments":true,"path":"archives/index.html","permalink":"https://yantao1995.github.io/archives/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-11-20T13:25:18.000Z","updated":"2022-05-29T08:54:59.583Z","comments":true,"path":"about/index.html","permalink":"https://yantao1995.github.io/about/index.html","excerpt":"","text":"个人信息 严涛/男/1995.09.29 本科/软件工程/攀枝花学院 (2015.9-2019.6) Github：https://github.com/yantao1995 Email：1173904005@qq.com 工作经历成都网信天成科技有限公司区块链交易所 work：后台，合约交易，监控，运营工具, 量化交易。 成都精灵云科技有限公司（实习）2018.12-2019.3镜像仓库管理学习了云计算相关的知识。然后在镜像仓库管理的负责人指导下，做相关的开发工作。 work：镜像打包，镜像漏洞扫描。 生存技能 语言：Golang ，Java，C，C++，C# 语言生态：Gin，Iris , Xorm , Gorm，Beego，SpringBoot，Mybatis 前端：Bootstrap，JQuery，ajax，js，css，html 数据库相关：MySQL，redis，SQL Server, MongoDB 其他：Git，linux 云计算相关 ： Docker ， k8s 摸索中… 技能摸索中，任重而道远…"},{"title":"文章分类","date":"2019-09-21T02:19:39.000Z","updated":"2019-09-21T03:34:08.144Z","comments":true,"path":"categories/index.html","permalink":"https://yantao1995.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-06-07T07:39:54.918Z","updated":"2019-09-21T03:53:23.846Z","comments":true,"path":"tags/index.html","permalink":"https://yantao1995.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"elasticsearch 搭建及简单rest操作","slug":"elasticsearch-搭建及简单rest操作","date":"2022-01-19T10:54:00.000Z","updated":"2022-01-20T07:45:11.532Z","comments":true,"path":"2022/01/19/elasticsearch-搭建及简单rest操作/","link":"","permalink":"https://yantao1995.github.io/2022/01/19/elasticsearch-搭建及简单rest操作/","excerpt":"学习 elasticsearch 的简单笔记，记不住了就来看看。","text":"学习 elasticsearch 的简单笔记，记不住了就来看看。 ES部署 host文件ip地址映射 12345vim /etc/hosts192.168.25.129 node1192.168.25.130 node2192.168.25.131 node3 单机部署 不能使用root账户，新建账户，赋予权限运行 12345adduser elasticsearch //添加用户passwd elasticsearch //创建密码chown -R elasticsearch elasticsearch_path //赋予文件夹权限su elasticsearch //切换用户./elasticsearch_path/bin/./elasticsearch -d //后台启动 启动后只能 localhost:9200 访问，需要ip访问则要修改 elasticsearch.yml 文件. 才可以 ip:9200访问 12network.host: 本机ipcluster.initial_master_nodes: [&quot;本机ip&quot;] 启动后若提示虚拟内存过小 12345678910111213141516// 永久生效vim /etc/security/limits.conf* soft nofile 65535* hard nofile 65535* soft nproc 4096* hard nproc 4096其中nofile : 一个进程最多能打开的的文件数其中nproc : 一个用户最多能创建的进程数其中 * 代表所有用户，也可以直接使用指定用户名//或者临时生效ulimit -u 4096 启动后若提示当前用户最大内存过小 12345678//打开文件vim /etc/sysctl.conf//添加vm.max_map_count=262144//执行命令，立即生效sysctl -p 集群配置 elasticsearch.yml 12345678910111213141516171819202122232425262728#集群名称cluster.name: cluster-es #当前集群内所有主机的名称应该一致#节点名称 不能重复 ----此处需要修改node.name: node1 #ip地址 ---- 此处需要修改network.host: node1#是不是有资格主节点node.master: truenode.data: truehttp.port: 9200#head 插件需要的配置http.cors.allow-origin: &quot;*&quot;http.cors.enabled: truehttp.max_content_length: 200mb#es7 之后新增的，用于初始化新集群时来选举leadercluster.initial_master_nodes: [&quot;node1&quot;,&quot;node2&quot;,&quot;node3&quot;]#es7 之后新增的，节点发现 ----- 此处需要修改discovery.seed_hosts: [&quot;node1:9300&quot;,&quot;node2:9300&quot;,&quot;node3:9300&quot;]network.tcp.keep_alive: truenetwork.tcp.no_delay: truetransport.tcp.compress: true#集群内同时启动的数据任务个数，默认2cluster.routing.allocation.cluster_concurrent_rebalance: 16#添加或删除节点及负载均衡时并发恢复的线程个数,默认4cluster.routing.allocation.node_concurrent_recoveries: 16#初始化数据恢复时，并发恢复线程的个数，默认4cluster.routing.allocation.node_initial_primaries_recoveries: 16 索引 相当于 mysql 中的一个库 1234567891011### 创建索引PUT http://192.168.25.128:9200/shopping#### 获取单个索引GET http://192.168.25.128:9200/shopping#### 获取全部索引GET http://192.168.25.128:9200/_cat/indices?v#### 删除索引DELETE http://192.168.25.128:9200/shopping 文档 相当于 mysql 中的行数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167### 创建文档POST http://192.168.25.128:9200/shopping/_docContent-Type: application/json&#123; &quot;title&quot;: &quot;小米手机&quot;, &quot;category&quot;: &quot;小米&quot;, &quot;images&quot;: &quot;asdasd/xm.jpg&quot;, &quot;price&quot;: 399.00&#125;### 创建文档 指定id# 指定id http://192.168.25.128:9200/shopping/_doc/id1002# 指定创建 http://192.168.25.128:9200/shopping/_create/id1002PUT http://192.168.25.128:9200/shopping/_create/id1004Content-Type: application/json&#123; &quot;title&quot;: &quot;小米手机&quot;, &quot;category&quot;: &quot;小米&quot;, &quot;images&quot;: &quot;asdasd/xm.jpg&quot;, &quot;price&quot;: 399.00&#125;#### 主键查询#全部查询 GET http://192.168.25.128:9200/shopping/_search###单个查询GET http://192.168.25.128:9200/shopping/_doc/id1002### 全量更新PUT http://192.168.25.128:9200/shopping/_doc/id1002Content-Type: application/json&#123; &quot;title&quot;: &quot;小米手机1&quot;, &quot;category&quot;: &quot;小米1&quot;, &quot;images&quot;: &quot;asdasd/xm.jpg&quot;, &quot;price&quot;: 10.00&#125;### 局部更新POST http://192.168.25.128:9200/shopping/_update/id1003Content-Type: application/json&#123; &quot;doc&quot;:&#123; &quot;title&quot;:&quot;华为手机&quot;, &quot;price&quot;: 20 &#125;&#125;###删除DELETE http://192.168.25.128:9200/shopping/_doc/id1002###### 高级查询###条件查询GET http://192.168.25.128:9200/shopping/_searchContent-Type: application/json&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;category&quot;:&quot;小米&quot; &#125; &#125;&#125;###条件查询 全量GET http://192.168.25.128:9200/shopping/_searchContent-Type: application/json&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;&#125;###对字符串字段排序,聚合 需要修改### url说明: ip:port/索引/_mapping?pretty PUT http://192.168.25.128:9200/shopping/_mapping?pretty Content-Type: application/json&#123; &quot;properties&quot;: &#123; &quot;price&quot;: &#123; //需要操作的字段， &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true &#125; &#125;&#125;###条件查询 分页排序筛选GET http://192.168.25.128:9200/shopping/_searchContent-Type: application/json&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;, &quot;from&quot;:1, //offset &quot;size&quot;:2, //limit &quot;_source&quot;:[&quot;title&quot;], //只需要的数据，不填就查全部 &quot;sort&quot;:&#123; //排序 &quot;price&quot;:&#123; &quot;order&quot;:&quot;desc&quot; &#125; &#125; &#125;###条件查询 条件匹配GET http://192.168.25.128:9200/shopping/_searchContent-Type: application/json&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; //条件 &quot;must&quot;:[ // must 多个条件同时成立 ， should 多个条件任意成立 &#123; &quot;match&quot;:&#123; //只要包含有就匹配 &quot;category&quot;:&quot;小米&quot; &#125; &#125;, &#123; &quot;match_phrase&quot;:&#123; //全词匹配 &quot;price&quot;:200 &#125; &#125; ], &quot;filter&quot;:&#123; //过滤 &quot;range&quot; :&#123; //范围 &quot;price&quot;:&#123; &quot;gt&quot;:20 //大于20 &#125; &#125; &#125; &#125; &#125;, &quot;highlight&quot;:&#123; //高亮显示，该字段增加html样式 &quot;fields&quot;:&#123; &quot;category&quot;:&#123;&#125; &#125; &#125;&#125;###条件查询 聚合操作GET http://192.168.25.128:9200/shopping/_searchContent-Type: application/json&#123; &quot;aggs&quot;:&#123; //聚合操作 &quot;price_group&quot;:&#123; //名称，随意起名 &quot;terms&quot;:&#123; // 具体操作 term分组 avg平均值 &quot;field&quot;:&quot;price&quot; //分组字段 &#125; &#125; &#125;, &quot;size&quot;:1&#125; 映射 索引的映射相当于数据库中的表结构，对数据结构进行定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748###创建user indexPUT http://192.168.25.128:9200/user###添加PUT http://192.168.25.128:9200/user/_mappingContent-Type: application/json&#123; &quot;properties&quot;:&#123; &quot;name&quot;:&#123; &quot;type&quot;:&quot;text&quot;, //字段类型 可以分词 &quot;index&quot; :true // 字段可以索引 &#125;, &quot;sex&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, // 不能分词，必须全部匹配 &quot;index&quot; :true // 字段可以索引 &#125;, &quot;tel&quot;:&#123; &quot;type&quot;:&quot;keyword&quot;, // 不能分词，必须全部匹配 &quot;index&quot; :false // 字段不可以索引 就是不能被查询 &#125; &#125;&#125;###查询GET http://192.168.25.128:9200/user/_mapping### 增加数据PUT http://192.168.25.128:9200/user/_create/1001Content-Type: application/json&#123; &quot;name&quot;: &quot;小米&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;tel&quot;: &quot;1111&quot;&#125;### 查询数据GET http://192.168.25.128:9200/user/_searchContent-Type: application/json&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;tel&quot;:&quot;1111&quot; &#125; &#125;&#125; 集群123### 集群状态查看GET http://192.168.25.129:9200/_cat/nodes","categories":[{"name":"es","slug":"es","permalink":"https://yantao1995.github.io/categories/es/"}],"tags":[{"name":"es","slug":"es","permalink":"https://yantao1995.github.io/tags/es/"},{"name":"笔记","slug":"笔记","permalink":"https://yantao1995.github.io/tags/笔记/"}],"author":"Tany"},{"title":"kafka 集群搭建笔记","slug":"kafka-集群搭建笔记","date":"2021-12-28T08:09:00.000Z","updated":"2022-01-20T09:33:30.671Z","comments":true,"path":"2021/12/28/kafka-集群搭建笔记/","link":"","permalink":"https://yantao1995.github.io/2021/12/28/kafka-集群搭建笔记/","excerpt":"学习 kafka 的简单笔记，记不住了就来看看。","text":"学习 kafka 的简单笔记，记不住了就来看看。 准备工作 准备并配置 jdk 环境 【以下步骤均在在3台机器上操作】 启动zookeeper 集群 【高于2.8版本就不需要启动了】 解压 kafka 1tar -zxvf kafka_2.13-2.6.3.tgz 进入 config 目录修改配置 12345678910111213vim server.properties//修改当前机器的 broker id ，分别填写3台机器的编号broker.id=0// 此log 非彼 log， 这是kafka的消息数据文件log.dirs=/opt/moudle/kafka_2.13-2.6.3/kafkalogs// 修改 zookeeper 的集群地址和端口zookeeper.connect=192.168.25.129:2181,192.168.25.130:2181,192.168.25.131:2181//修改本机的监听端口listeners=PLAINTEXT://192.168.25.129:9092 启动&amp;停止 进入 kafka 根目录 非后台启动 1bin/kafka-server-start.sh config/server.properties 后台启动 1bin/kafka-server-start.sh -daemon config/server.properties 安装jps后，使用命令 jps 即可看到启动后的程序 1234567jps---2208 QuorumPeerMain3811 Kafka3885 Jps--- 停止 1bin/kafka-server-stop.sh 简单测试 topic 1234567891011121314151617181920//创建 //partitions 尽量与broker数量相同，读写性能高，replication-factor 不能超过broker数量bin/kafka-topics.sh --zookeeper node1:2181 --create --topic test2 --partitions 3 --replication-factor 3---Created topic test2.---//查看bin/kafka-topics.sh --zookeeper node1:2181 --describe --topic test1---Topic: test1 PartitionCount: 3 ReplicationFactor: 3 Configs: Topic: test1 Partition: 0 Leader: 2 Replicas: 2,0,1 Isr: 2,1,0 Topic: test1 Partition: 1 Leader: 2 Replicas: 0,1,2 Isr: 2,0,1 Topic: test1 Partition: 2 Leader: 2 Replicas: 1,2,0 Isr: 2,1,0--- console-producer 12//向 test1 发布消息bin/kafka-console-producer.sh --bootstrap-server node1:9092 --topic test1 console-coumser （对于老的消费者，由–zookeeper参数设置；对于新的消费者，由–bootstrap-server参数设置如果使用了–zookeeper参数,那么consumer的信息将会存放在zk之中） 1bin/kafka-console-consumer.sh --bootstrap-server node2:9092 --topic test1 --from-beginning","categories":[{"name":"kafka","slug":"kafka","permalink":"https://yantao1995.github.io/categories/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://yantao1995.github.io/tags/kafka/"}],"author":"Tany"},{"title":"zookeeper 集群搭建笔记","slug":"zookeeper-集群搭建笔记","date":"2021-12-20T07:42:00.000Z","updated":"2022-01-20T09:33:39.110Z","comments":true,"path":"2021/12/20/zookeeper-集群搭建笔记/","link":"","permalink":"https://yantao1995.github.io/2021/12/20/zookeeper-集群搭建笔记/","excerpt":"学习 zookeeper 的简单笔记，记不住了就来看看。","text":"学习 zookeeper 的简单笔记，记不住了就来看看。 配置 准备3台机器，然后分别进行下面的操作 安装并配置jdk环境 解压zookeeper 1tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz 进入conf目录 12345678910111213cp zoo_sample.cfg zoo.cfgvim zoo.cfg//其他配置默认//修改 dataDir数据文件存放地址和集群dataDir=/opt/moudle/apache-zookeeper-3.5.9-bin/data//增加 dataDir数据文件存放地址和集群//说明 节点编号 = ip ：zookeeper服务端口 ：节点选举端口 server.0=192.168.25.129:2888:3888server.1=192.168.25.130:2888:3888server.2=192.168.25.131:2888:3888 进入刚刚配置的 dataDir 文件夹 12345//创建 myid 文件vim myid//写入id,比如当前为 server.0 节点，就直接写入00 异常 若启动失败，检查防火墙。 1234//查看防火墙状态service iptables status//关闭防火墙chkconfig iptables off 启动 进入 bin目录 12345678//启动zkServer.sh start//停止zkServer.sh stop// 重启zkServer.sh restart// 状态zkServer.sh status","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://yantao1995.github.io/categories/zookeeper/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://yantao1995.github.io/tags/zookeeper/"}],"author":"Tany"},{"title":"一颗精简的前缀树设计","slug":"一颗精简的前缀树设计","date":"2021-09-21T09:56:00.000Z","updated":"2022-01-20T08:59:23.777Z","comments":true,"path":"2021/09/21/一颗精简的前缀树设计/","link":"","permalink":"https://yantao1995.github.io/2021/09/21/一颗精简的前缀树设计/","excerpt":"做题有感：一道键值映射背后的前缀树","text":"做题有感：一道键值映射背后的前缀树 leetcode第677题 （键值映射） 实现一个 MapSum 类，支持两个方法，insert 和 sum： MapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。 提示： 1 &lt;= key.length, prefix.length &lt;= 50 key 和 prefix 仅由小写英文字母组成 1 &lt;= val &lt;= 1000 最多调用 50 次 insert 和 sum 123456789101112输入：[&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;][[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]输出：[null, null, 3, null, 5]解释：MapSum mapSum = new MapSum();mapSum.insert(&quot;apple&quot;, 3); mapSum.sum(&quot;ap&quot;); // return 3 (apple = 3)mapSum.insert(&quot;app&quot;, 2); mapSum.sum(&quot;ap&quot;); // return 5 (apple + app = 3 + 2 = 5) 思路 : 因为相同的前缀下的所有值要求一个总和，并且可以替换当前已经有的值。如果仅用一个map计数的话，需要遍历整个map来做字符串匹配。 所以此处选择使用前缀树来实现。又由于root根结点可能存在多个。所有在初始化时，返回了一个root的上层结点来保存所有的根结点。 使用前缀树，则需要标识，哪些结点是真正的单词，哪些结点只是共有的父节点。所以结点中应该包含标识，以及如果是单词结点，则包含对应的val。 获取值时，使用内置双向链表list，前取后加，作为队列来实现广度遍历 实现 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type MapSum struct &#123; isWords bool val int NextMap map[byte]*MapSum //前缀树&#125;func Constructor() MapSum &#123; return MapSum&#123; isWords: false, val: 0, NextMap: map[byte]*MapSum&#123;&#125;, &#125;&#125;func (this *MapSum) Insert(key string, val int) &#123; that := this for i := 0; i &lt; len(key); i++ &#123; if _, ok := that.NextMap[key[i]]; !ok &#123; that.NextMap[key[i]] = &amp;MapSum&#123; isWords: false, val: 0, NextMap: map[byte]*MapSum&#123;&#125;, &#125; &#125; if i == len(key)-1 &#123; that.NextMap[key[i]].isWords = true that.NextMap[key[i]].val = val &#125; that = that.NextMap[key[i]] &#125;&#125;func (this *MapSum) Sum(prefix string) int &#123; total := 0 that := this for k := range prefix &#123; if _, ok := that.NextMap[prefix[k]]; !ok &#123; return 0 &#125; that = that.NextMap[prefix[k]] &#125; queue := list.New() queue.PushBack(that) for queue.Len() &gt; 0 &#123; element := queue.Front() if ms, ok := element.Value.(*MapSum); ok &amp;&amp; ms != nil &#123; if ms.isWords &#123; total += ms.val &#125; for k := range ms.NextMap &#123; queue.PushBack(ms.NextMap[k]) &#125; &#125; queue.Remove(element) &#125; return total&#125; 可以优化的点：每个结点中可以增加一个字段totalVal来存所有子节点的累积值，父结点 isWords == true 的时候，可以在 insert 的时候就累加 val 进去。 这样子结点获取的时候，不需要再逐一向下遍历。但是需要注意的是，如果该结点为替换值的操作，则需要向上层操作所有为单词的结点。","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"},{"name":"algor","slug":"algor","permalink":"https://yantao1995.github.io/tags/algor/"}],"author":"Tany"},{"title":"mongodb之golang官方驱动包bson对象笔记","slug":"mongodb与golang的映射笔记","date":"2021-06-25T09:26:00.000Z","updated":"2022-01-20T09:36:17.561Z","comments":true,"path":"2021/06/25/mongodb与golang的映射笔记/","link":"","permalink":"https://yantao1995.github.io/2021/06/25/mongodb与golang的映射笔记/","excerpt":"学习 mongo官方包的简单笔记，记不住了就来看看。","text":"学习 mongo官方包的简单笔记，记不住了就来看看。 bson 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Copyright (C) MongoDB, Inc. 2017-present.//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may// not use this file except in compliance with the License. You may obtain// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0//// Based on gopkg.in/mgo.v2/bson by Gustavo Niemeyer// See THIRD-PARTY-NOTICES for original license terms.// +build go1.9package bson // import &quot;go.mongodb.org/mongo-driver/bson&quot;import ( &quot;go.mongodb.org/mongo-driver/bson/primitive&quot;)// Zeroer allows custom struct types to implement a report of zero// state. All struct types that don&apos;t implement Zeroer or where IsZero// returns false are considered to be not zero.type Zeroer interface &#123; IsZero() bool&#125;// D is an ordered representation of a BSON document. This type should be used when the order of the elements matters,// such as MongoDB command documents. If the order of the elements does not matter, an M should be used instead.//// Example usage://// bson.D&#123;&#123;&quot;foo&quot;, &quot;bar&quot;&#125;, &#123;&quot;hello&quot;, &quot;world&quot;&#125;, &#123;&quot;pi&quot;, 3.14159&#125;&#125;type D = primitive.D// E represents a BSON element for a D. It is usually used inside a D.type E = primitive.E// M is an unordered representation of a BSON document. This type should be used when the order of the elements does not// matter. This type is handled as a regular map[string]interface&#123;&#125; when encoding and decoding. Elements will be// serialized in an undefined, random order. If the order of the elements matters, a D should be used instead.//// Example usage://// bson.M&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;hello&quot;: &quot;world&quot;, &quot;pi&quot;: 3.14159&#125;type M = primitive.M// An A is an ordered representation of a BSON array.//// Example usage://// bson.A&#123;&quot;bar&quot;, &quot;world&quot;, 3.14159, bson.D&#123;&#123;&quot;qux&quot;, 12345&#125;&#125;&#125;type A = primitive.A bson.D document 1234567// D is an ordered representation of a BSON document. This type should be used when the order of the elements matters,// such as MongoDB command documents. If the order of the elements does not matter, an M should be used instead.//// Example usage://// bson.D&#123;&#123;&quot;foo&quot;, &quot;bar&quot;&#125;, &#123;&quot;hello&quot;, &quot;world&quot;&#125;, &#123;&quot;pi&quot;, 3.14159&#125;&#125;type D []E 表示有序bson文档，传参使用。顺序不能乱，比如筛选，分组，求和。 bson.E element 12345// E represents a BSON element for a D. It is usually used inside a D.type E struct &#123; Key string Value interface&#123;&#125;&#125; 表示Key,Value 属性。 bson.M map 12345678// M is an unordered representation of a BSON document. This type should be used when the order of the elements does not// matter. This type is handled as a regular map[string]interface&#123;&#125; when encoding and decoding. Elements will be// serialized in an undefined, random order. If the order of the elements matters, a D should be used instead.//// Example usage://// bson.M&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;hello&quot;: &quot;world&quot;, &quot;pi&quot;: 3.14159&#125;.type M map[string]interface&#123;&#125; 表示无序bson文档，map类型。 bson.A array 123456// An A is an ordered representation of a BSON array.//// Example usage://// bson.A&#123;&quot;bar&quot;, &quot;world&quot;, 3.14159, bson.D&#123;&#123;&quot;qux&quot;, 12345&#125;&#125;&#125;type A []interface&#123;&#125; 表示有序bson数组。 同时使用 or , and 查询 实现类似 where k = v and ( takeruser = a or makeruser = b ) 1234567891011121314151617181920 terms := map[string]interface&#123;&#125;&#123;&#125;filter := bson.D&#123;&#125;for k, v := range terms &#123; if k == &quot;userId&quot; &#123; fltr := bson.E&#123; Key: &quot;$or&quot;, Value: bson.A&#123;bson.M&#123; &quot;takeruser&quot;: v, &#125;, bson.M&#123; &quot;makeruser&quot;: v, &#125;&#125;, &#125; filter = append(filter, fltr) &#125; else &#123; filter = append(filter, bson.E&#123; Key: k, Value: v, &#125;) &#125;&#125;","categories":[{"name":"mongo","slug":"mongo","permalink":"https://yantao1995.github.io/categories/mongo/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/tags/golang/"},{"name":"mongo","slug":"mongo","permalink":"https://yantao1995.github.io/tags/mongo/"}],"author":"Tany"},{"title":"mongodb一些简单操作笔记","slug":"mongodb一些简单操作笔记","date":"2021-05-22T09:28:00.000Z","updated":"2022-01-20T09:31:55.030Z","comments":true,"path":"2021/05/22/mongodb一些简单操作笔记/","link":"","permalink":"https://yantao1995.github.io/2021/05/22/mongodb一些简单操作笔记/","excerpt":"学习 mongo 操作的简单笔记，记不住了就来看看。","text":"学习 mongo 操作的简单笔记，记不住了就来看看。 插入文档MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：123db.COLLECTION_NAME.insert(document)或db.COLLECTION_NAME.save(document) 区别 save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。 insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。 db.collection.insertOne() 和 db.collection.insertMany() 语法： 1234567单个:db.collection.insertOne( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 12345678一个或多个:db.collection.insertMany( [ &lt;document 1&gt; , &lt;document 2&gt;, ... ], &#123; writeConcern: &lt;document&gt;, ordered: &lt;boolean&gt; &#125;) 参数说明： document：要写入的文档。 writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。 ordered：指定是否按顺序写入，默认 true，按顺序写入。 查询文档db.collection.find(query, projection) query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 字段样例: _id v c abv 5efed2b5282700007500040a adsd (N/A) 5efed4dd2827000075000433 (N/A) c (Array) 4 Elements 5efed4dd2827000075000414 (N/A) c (Array) 4 Elements 查询样例: 123db.test2.find(&#123;v:&quot;adsd&quot;,abv: null&#125;)// db.test2.findOne(&#123;v:&quot;adsd&quot;,abv: null&#125;) // 只返回第一个 返回样例: _id v c 5efed2b5282700007500040a adsd 结论 null 字段不返回 空 字段返回 空 字段比较 操作 格式 范例 RDBMS中的类似语句 等于 {&lt;key&gt;:&lt;value&gt;} db.col.find({“by”:”菜鸟教程”}).pretty() where by = ‘菜鸟教程’ 小于 {&lt;key&gt;:{$lt:}} db.col.find({“likes”:{$lt:50}}).pretty() where likes &lt; 50 小于或等于 {&lt;key&gt;:{$lte:}} db.col.find({“likes”:{$lte:50}}).pretty() where likes &lt;= 50 大于 {&lt;key&gt;:{$gt:}} db.col.find({“likes”:{$gt:50}}).pretty() where likes &gt; 50 大于或等于 {&lt;key&gt;:{$gte:}} db.col.find({“likes”:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {&lt;key&gt;:{$ne:}} db.col.find({“likes”:{$ne:50}}).pretty() where likes != 50 and or and 1db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() or 查询键 by 值为 菜鸟教程 或键 title 值为 MongoDB 教程 的文档。 1db.col.find(&#123;$or:[&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 联合使用 类似常规 SQL 语句为： ‘where likes&gt;50 AND (by = ‘菜鸟教程’ OR title = ‘MongoDB 教程’)’ 1db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 分页处理 类似mysql的 limit offset 使用 limit(输出文档的行数) skip(跳过的文档行数) 排序 sort({KEY:1}) 升序 sort({KEY:-1}) 降序 索引 语法 : db.collection.createIndex(keys, options) 说明 : Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。 实例：db.col.createIndex({&quot;title&quot;:1}) 多个字段创建索引(复合索引) 实例：db.col.createIndex({&quot;title&quot;:1,&quot;description&quot;:-1}) 可选参数列表: 参数 类型 描述 background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 dropDups Boolean 3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false. sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. 后台创建索引实例db.values.createIndex({open: 1, close: 1}, {background: true}) 更新文档update() 和 save() update()语法： 123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 更新样例 12345678db.test2.update(&#123;v:&quot;vvv&quot;&#125;, // 条件 v = &quot;vvv&quot;&#123;$set:&#123;v:&quot;aaa&quot;,abv:&quot;asd&quot;&#125;&#125;, //set v=&quot;aaa&quot; and abv= &quot;asd&quot; &#123; upsert: true, //不存在就添加 multi:true //更新多条 &#125;) 省略 upsert ,multi … 12345678db.test2.update(&#123;v:&quot;aaa&quot;&#125;,&#123;$set:&#123;v:&quot;azxxc&quot;&#125;&#125;,true,true) sava() 通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入。语法格式如下：123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明： document : 文档数据。 writeConcern :可选，抛出异常的级别。 样例: 带 ObjectId 12345db.test2.save(&#123;&quot;_id&quot;:ObjectId(&quot;5efee712e5ca213e2735928c&quot;), v :&quot;qwerr&quot;&#125;) 不带 ObjectId 12345db.test2.save(&#123;&quot;_id&quot;:&quot;5efee712e5ca213e2735928c&quot;, v :&quot;qwerr&quot;&#125;) ObjectId 必填，否则第一次save会变成添加，第二次sava才能识别 更多实例:12只更新第一条记录：db.col.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; ); 12全部更新：db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true ); 12只添加第一条：db.col.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false ); 12全部添加进去:db.col.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true ); 12全部更新：db.col.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true ); 12只更新第一条记录：db.col.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false ); 删除文档remove() 方法的基本语法格式如下所示： 2.6版本之前: 1234db.collection.remove( &lt;query&gt;, &lt;justOne&gt;) 2.6 版本之后: 1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 操作样例: 1234db.test2.remove(&#123;v:&quot;a&quot;&#125;false) 返回结果: 1WriteResult(&#123; &quot;nRemoved&quot; : 2, &quot;writeConcernError&quot; : [ ] &#125;) remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法 如删除集合下全部文档：db.inventory.deleteMany({}) 删除 status 等于 A 的全部文档：db.inventory.deleteMany({ status : &quot;A&quot; }) 删除 status 等于 D 的一个文档：db.inventory.deleteOne( { status: &quot;D&quot; } ) 知识点 remove() 方法 并不会真正释放空间。需要继续执行 db.repairDatabase() 来回收磁盘空间。 123db.repairDatabase()或者db.runCommand(&#123; repairDatabase: 1 &#125;)","categories":[{"name":"mongo","slug":"mongo","permalink":"https://yantao1995.github.io/categories/mongo/"}],"tags":[{"name":"mongo","slug":"mongo","permalink":"https://yantao1995.github.io/tags/mongo/"}],"author":"Tany"},{"title":"redis 的其他笔记","slug":"redis-的其他笔记","date":"2020-11-20T11:20:00.000Z","updated":"2022-01-20T09:35:26.501Z","comments":true,"path":"2020/11/20/redis-的其他笔记/","link":"","permalink":"https://yantao1995.github.io/2020/11/20/redis-的其他笔记/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。 一些基本概念Redis的高并发和快速原因 redis是基于内存的，内存的读写速度非常快； redis是单线程的，省去了很多上下文切换线程的时间； redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。 Object对象 （每一个键和值都是一个对象） redisObject结构 123456789101112131415161718typedef struct redisObject &#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 对象最后一次被访问的时间 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ // 引用计数 int refcount; // 指向实际值的指针 void *ptr;&#125; robj; refcount引用计数(内存回收&amp;对象共享) 内存回收 在创建一个新对象时，引用计数的值被初始化为1 当对象被一个新程序使用时，它的引用计数值会加1 当对象不再被一个程序使用时，它的引用计数会减1 当对象的引用计数变成0时，所占用的内存会被释放。 对象共享：多个键共享同一个值对象（3.0版本 0-9999整数值） 将键的值指针指向一个现有的值对象 该值对象的引用计数加1 lru空转时长 该属性记录了对象最后一次被命令程序访问的时间 object idletime 命令会降现在的时间减去lru得到空转时长 空转时长较高的部分键会优先被服务器释放，从而回收内存 5大数据类型 字段 底层实现 string 1. sds 简单动态字符串(编码为：raw[此时内存结构与SDS结构一致，内存分配次数为两次，创建redisObject对象和sdshdr结构]或者embstr[内存结构做了优化，用于保存顿消的字符串；内存分配也只需要一次就可完成，分配一块连续的空间即可])，2. 直接存储(编码int) hash 1. hashtable 字典+哈希表+哈希节点,2 ziplist 压缩列表 list 1. adlist 双向链表，2. 压缩列表 set 1. intset整数集合,hashtable 哈希表 类似java的hashset zset 1. 压缩列表,2. skiplist 字典+跳跃表 string (int,embstr,raw) int： 整数值 embstr: 简单动态字符串（最直观的区别：value短(小于32字节)，一次内存分配包含redisObject结构和sdshdr结构，空间连续） raw：简单动态字符串（最直观的区别：value长(大于32字节)，两次内存分配分别创建redisObject结构和sdshdr结构） 在Redis中，存储long、double类型的浮点数是先转换为字符串再进行存储的。 raw与embstr编码效果是相同的，不同在于内存分配与释放，raw两次，embstr一次。 embstr内存块连续，能更好的利用缓存在来的优势 int编码和embstr编码如果做追加字符串等操作，满足条件下会被转换为raw编码；embstr编码的对象是只读的，一旦修改会先转码到raw。 list ziplist：压缩列表 adlist：双端链表（linkedlist） 列表对象使用ziplist编码需要满足两个条件：一是所有字符串长度都小于64字节，二是元素数量小于512，不满足任意一个都会使用linkedlist编码。 两个条件的数字可以在Redis的配置文件中修改，list-max-ziplist-value选项和list-max-ziplist-entries选项。 adlist双端链表*ptr指向的链表内元素就是string的字符串对象，字符串对象是唯一个在五大对象中作为嵌套对象使用的。 hash ziplist：压缩列表 ht：使用字典实现哈希对象hashtable 哈希对象使用ziplist编码需要满足两个条件：一是所有键值对的键和值的字符串长度都小于64字节；二是键值对数量小于512个；不满足任意一个都使用hashtable编码。 以上两个条件可以在Reids配置文件中修改hash-max-ziplist-value选项和hash-max-ziplist-entries选项。 set intset:整数集合 ht：字典实现的集合对象hashtable 集合对象使用intset编码需要满足两个条件：一是所有元素都是整数值；二是元素个数小于等于512个；不满足任意一条都将使用hashtable编码。 以上第二个条件可以在Redis配置文件中修改set-max-intset-entries选项。 zset ziplist：压缩列表 skiplist:跳跃表+字典实现有序集合对象 [单使用字典也可以实现,但因为无序，尽管虽然查找O(1),却在排序时浪费空间O(n)来存储结果。] [单使用跳跃表也可以实现，虽然有序了，但是根据成员查找分值将会从O(1)上升到O(logN)] 跳跃表优点是有序，但是查询分值复杂度为O(logn)；字典查询分值复杂度为O(1) ，但是无序，所以结合连个结构的有点进行实现。 虽然采用两个结构但是集合的元素成员和分值是共享的，两种结构通过指针指向同一地址，不会浪费内存。 有序集合对象使用ziplist编码需要满足两个条件：一是所有元素长度小于64字节；二是元素个数小于128个；不满足任意一条件将使用skiplist编码。 以上两个条件(3中)可以在Redis配置文件中修改zset-max-ziplist-entries选项和zset-max-ziplist-value选项。 列表（list）、哈希（hash）、集合（set）、有序集合（zset）底层实现都用到了压缩列表结构，并且使用压缩列表结构的条件都是在元素个数比较少、字节长度较短的情况下 expire/pexpire 过期键最终过期命令的转换 最终都变成pexpireat expire -&gt; pexpire -&gt; pexpireat expireat -&gt; pexpireat expire 指向一个维护键过期时间的 dict字典 字典中key为键的名称，value为long long类型的 毫秒精度的Unix时间戳 移除过期时间 persist 删除expire指向的dict字典内的key 过期键删除策略 定时删除：设置过期键的同时，创建一个定时器timer，过期就立即删除。 惰性删除：过期了也不管，获取时检查是否过期，过期就删。 定期删除：每隔一段时间，对库检查并删除过期键。 定时删除：cpu负载加大，内存得到很好释放 惰性删除：对cpu友好，但是对内存不友好 定期删除：介于二者之间，但是间隔得根据实际情况合理设置 备份载入RDB载入 主服务器模式：过期键不载入 服务器模式：无论是否过期，都载入 AOF 载入 键过期但还未删除时，AOF文件不会因为过期而影响。 当删除触发时，程序会向AOF文件追加一条del命令，显式删除 重写 重写过程会检查，过期的键不会保存。 主从复制 由主服务器来控制从服务器统一的删除过期键 主服务器删除过期键之后，显式的向所有从服务器发送del命令。 从服务器在未接收到主服务器发来的del命令前，即便是过期了也不会删除，继续像未过期一样处理。 接收到del命令之后，才会删除过期键。 RDB save: 停止服务来进行备份 bgsave：fork一个子进程来进行备份 AOF创建 命令追加append 文件写入 文件同步 重写rewrite 创建一个新的AOF，来代替原来的AOF文件，将冗余命令去掉。（多条命令合并成一条） 后台重写，为了保证主进程仍然能处理请求，设置AOF重写缓冲区，为了保证数据一致。写命令会同时发送给AOF缓冲区和AOF重写缓冲区。 执行客户端发来的命令。 将执行后的写命令追加到AOF缓冲区。 将执行后的写命令追加到AOF重写缓冲区。 主从复制旧版复制(同步,命令传播) 缺陷： 初次复制：正常完成。 断线后重复制：也能正常完成，但是效率非常低。比如：断线这段时间只有几条数据没复制，但是主服务器生成的RDB文件却包含了之前已经完成复制了的数据。重复发送了很多冗余数据。 同步 从服务器向主服务器发送sync命令。 收到sync命令的主服务器执行bgsave命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。 当主服务器的bgsave命令执行完毕后，主服务器会降bgsave命令生成RDB文件发送给从服务器。从服务器收到并载入，更新自己状态。 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行，更新自己状态。 命令传播 同步完成后，如果主服务器执行写命令后，主从服务器状态不一致了。 主服务器执行完后，命令会发送给从服务器执行，保持状态一致。 新版主从复制(2.8版本之后（psync代替了sync）) 两种同步机制： 完整重同步：初次复制的情况，发送完整的RDB文件。 部分重同步：处理断线后重连。 部分重同步 ： 断线连接后：从服务器发送psync命令给主服务器 主服务器回复+continue回复，表示执行部分重同步 从服务器接收+continue回复，准备执行部分重同步 主服务器发送待同步数据 psync细节： 3个部分： 主从服务器的复制偏移量 主服务器的复制积压缓冲区 服务器的运行id 复制偏移量 主从服务器都会维护一个复制偏移量： 主服务器每次向从服务器传播n个字节的数据时，就将自己的复制偏移量的值加上n。 从服务器每次收到主服务器传播来的n个字节的数据时，就将自己的复制偏移量加上n。 复制积压缓冲区 主服务器维护的一个固定长度先进先出的队列，默认1MB大小。 当从服务器重连后：通过psync命令将自己的复制偏移量offset发送给主服务器 如果offset之后的数据，仍然在复制积压缓冲区里，就执行部分重同步 如果不在，就执行完整重同步 服务器运行id 每个主从服务器都有自己的运行id 启动时自动生成，由40个随机的16进制字符组成。 用于同步时的相互识别 复制的实现 步骤： 设置主服务器的地址和端口 建立套接字socket连接 发送ping命令 身份验证 发送端口信息 同步 命令传播 高可用Sentinel哨兵（高可用解决方案） 一个或多个sentinel实例组成的系统可以监控任意个主从服务器，并在被监视的主服务器下线时，自动将其属下的某个从服务器提升为主服务器。 主服务器下线时，挑选其属下的一个从服务器，设置为新的主服务器。 sentinel系统向原主服务器属下的所有其他从服务器发送新的复制指令，让他们成为新主服务器的从服务器。 当已下线的原主服务器重新上线时，sentinel系统会将它设置成新主服务器的从服务器。 sentinel本质是一个运行在特殊模式下的redis服务器，初始化时不加载RDB或者AOF文件 常见缓存解决方案缓存穿透 描述： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。 解决方案： 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 布隆过滤器：先将存在的数据存入布隆过滤器，进行首次的过滤，若布隆过滤器中不存在则直接返回NULL 缓存击穿 描述： 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 解决方案： 设置热点数据永远不过期。 加互斥锁: 缓存中有数据，直接返回结果了 缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。 当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。 缓存雪崩 描述： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。 设置热点数据永远不过期。","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"}],"author":"Tany"},{"title":"redis底层实现之跳跃表","slug":"redis底层实现之跳跃表","date":"2020-09-20T09:17:00.000Z","updated":"2022-01-20T09:35:01.291Z","comments":true,"path":"2020/09/20/redis底层实现之跳跃表/","link":"","permalink":"https://yantao1995.github.io/2020/09/20/redis底层实现之跳跃表/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。 跳跃表SkipList 源码3.0 redis.h 2个地方使用 有序集合的键 集群节点中用作内部数据结构 基本概念 有序 平均时间复杂度 O(logN),最坏O(N) 123456789101112131415/* * 有序集合 */typedef struct zset &#123; // 字典，键为成员，值为分值 // 用于支持 O(1) 复杂度的按成员取分值操作 dict *dict; // 跳跃表，按分值排序成员 // 用于支持平均复杂度为 O(log N) 的按分值定位成员操作 // 以及范围操作 zskiplist *zsl;&#125; zset; zskiplist 用于保存跳跃表节点相关信息 123456789101112131415/* * 跳跃表 */typedef struct zskiplist &#123; // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level;&#125; zskiplist; header:指向表头节点。 tail:指向表尾节点。 level:记录目前跳跃表内，层数最大的节点的层数。 (不包含表头节点层数) length:记录跳跃表长度，即目前包含的节点数量。(不包含表头节点) zskiplistNode 跳跃表节点 123456789101112131415161718192021222324252627/* ZSETs use a specialized version of Skiplists *//* * 跳跃表节点 */typedef struct zskiplistNode &#123; // 成员对象 robj *obj; // 分值 double score; // 后退指针 struct zskiplistNode *backward; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; &#125; level[];&#125; zskiplistNode; level（层）: 保存节点中的各层，有多少层数组就有多大。层内包含前进指针和跨度。(前进指针用于访问该层的下一个节点。跨度表示到下一个节点中间间隔了多少个节点) 层数根据幂次定律（越大的数出现的概率越小），随机生成1~32之间的值作为level数组大小。也就是高度。 backward（后退指针）:指向当前节点的前一个节点。 score（分值）:各个节点的排序依据，从小到大的分值排列。 obj（成员对象）： 123456789101112131415161718typedef struct redisObject &#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 对象最后一次被访问的时间 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ // 引用计数 int refcount; // 指向实际值的指针 void *ptr;&#125; robj; 表头节点和其他节点构造一样，但是主要保存层数，所以分值，成员对象，后退指针都不会用到 迭代程序遍历时，从最高层，依次向下，选择到下一个节点跨度为1的层级，进入下一个节点直至null。","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"zset","slug":"zset","permalink":"https://yantao1995.github.io/tags/zset/"}],"author":"Tany"},{"title":"redis底层实现之整数集合","slug":"redis底层实现之整数集合","date":"2020-09-15T09:16:00.000Z","updated":"2022-01-20T09:35:12.124Z","comments":true,"path":"2020/09/15/redis底层实现之整数集合/","link":"","permalink":"https://yantao1995.github.io/2020/09/15/redis底层实现之整数集合/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。 整数集合intset 源码3.0 intset.h 集合键的底层实现之一 结构123456789101112typedef struct intset &#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];&#125; intset; contents：整数集合的每个元素都是 contents的一个元素item，各个项从小到大的顺序排列，不包含重复项。 length：记录了整数集合包含的元素数量，即 contents 的长度。 encoding：虽然contents是int8_t类型，但是保存的值类型取决于encoding。 编码类型范围： 123int16_t 范围 [-32768,32767]int32_t 范围 [-2147483648,2147483647]int64_t 范围 [-9223372936854775808,9223372036854775807] 编码类型决定了contents数组内元素分配的空间大小比如：int16_t编码， sizeof(int16_t)*5 = 16*5 = 80位 升级 概念：向一个int16_t数组的整数集合添加一个int64_t类型的整数值时，该整数集合的所有元素类型将会变成int64_t类型。 升级步骤： 根据新元素类型扩展整数集合底层数组空间大小，并为新元素分配空间。 转换现有所有元素转化类型后，依然保持有序。 新元素添加到指定位置。O(N) 升级后新元素的摆放位置:（因为引发升级的元素长度总比整数集合现有元素长度大，所以新元素在集合中要么最小，要么最大）： 最小情况，放置在整数集合的开头位置 （索引0） 最大情况，放置在整数集合的末尾位置 （索引 length-1） 作用： 提升整数集合的灵活性 C语言静态类型语言，为了避免错误，同一个数据结构保存同一类型 尽可能的节约内存 不一开始就直接使用int64_t类型，在需要的时候才向长度大的方向扩展 不支持降级：升级了之后就算该引起升级的元素删除了，整数集合仍然不会降级","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"set","slug":"set","permalink":"https://yantao1995.github.io/tags/set/"}],"author":"Tany"},{"title":"redis底层实现之Hash","slug":"redis底层实现之Hash","date":"2020-09-02T04:42:00.000Z","updated":"2022-01-20T09:34:44.212Z","comments":true,"path":"2020/09/02/redis底层实现之Hash/","link":"","permalink":"https://yantao1995.github.io/2020/09/02/redis底层实现之Hash/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。 Hash 源码3.0 dict.h 哈希表与哈希表节点 定义： 1234567891011121314151617181920212223242526272829303132333435363738394041/* * 哈希表 * * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。 */typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;&#125; dictht;/* * 哈希表节点 */typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; // 指向下个哈希表节点，形成链表 struct dictEntry *next;&#125; dictEntry; union简单理解:共用体,共用一个内存首地址，并且各种变量名都可以同时使用，操作也是共同生效。如此多的access内存手段，确实好用，不过这些“手段”之间却没法互相屏蔽——就好像数组+下标和指针+偏移一样。 （极致的内存压榨） table:数组中每个元素都是指向dictEntry节点的指针。 dictEntry 保存键值对，v使用union，可以是指针，也可以是uint64_t或者int64_t。（类型_t 是因为是 typedef 定义的，而不是新类型，原因是因为跨平台） 字典 dict定义： 12345678910111213141516171819202122/* * 字典 */typedef struct dict &#123; // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 目前正在运行的安全迭代器的数量 int iterators; /* number of iterators currently running */&#125; dict; type 和 privdata 指针类型，为了创建多态字典。 type 保存用于操作特定类型键值对的函数。 privdata 保存了需要穿给那些类型特定函数的可选参数。 dictType定义: 123456789101112131415161718192021222324/* * 字典类型特定函数 */typedef struct dictType &#123; // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj);&#125; dictType; 一般状态下的结构： dict 的 ht 指向 2个 dictht， dictht的table指向 dictEntry*[] dictEntry*[] 存储 dictEndty的键值对key,value节点。 123dict.ht -&gt; dictht[]dictht.table -&gt; dictEntry*[]dictEntry&#123;key,value&#125; 解决冲突 链地址法： 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，解决了键冲突的问题。 新节点添加在链表表头位置。（为了速度） rehash条件：扩容和收缩(依赖负载因子) 哈希表负载因子计算公式： load_factory = ht[0].used / ht[0].size (负载因子 = 哈希表已保存节点数量 / 哈希表大小) 扩容 程序没有执行BGSAVE命令或者BGREWRITEAOF(AOF重写)命令，并且哈希表的负载因子大于等于1 如果程序正在执行BGSAVE或者BGREWRITEAOF(AOF重写)命令并且哈希表的负载因子大于等于5。在执行RDB或者AOF重写操作时，redis会创建当前服务器的子进程执行相应操作，为了避免在子进程存在期间对哈希表进行扩展操作，将扩展因子提高。可以避RDB或者AOF重写时不必要的内存写入操作，最大限度的节约内存。 收缩：负载因子小于0.1进行收缩 渐进式rehash 概念：扩展或收缩哈希表时 ht[0] 的键值对 rehash到 ht[1] 不是一次完成，而是分多次，渐进式的。 原因：键值对数据量庞大时，一次性rehash的计算量可能会导致服务器在一段时间内停止服务。 步骤： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 过程中： 删除，查找，更新会同时在两个哈希表上进行。查找顺序：ht[0] -&gt; ht[1] 。 添加会在ht[1]上进行。保证了ht[0]只减不增，随着rehash操作最终变成空表。","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"hash","slug":"hash","permalink":"https://yantao1995.github.io/tags/hash/"}],"author":"Tany"},{"title":"redis底层实现之List","slug":"redis底层实现之List","date":"2020-08-24T07:51:00.000Z","updated":"2022-01-20T09:34:31.079Z","comments":true,"path":"2020/08/24/redis底层实现之List/","link":"","permalink":"https://yantao1995.github.io/2020/08/24/redis底层实现之List/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。对比quickList的源码版本 redis 6.0.5。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。对比quickList的源码版本 redis 6.0.5。 List列表版本3.2之前，list使用两种数据结构作为底层实现： 压缩列表ziplist （特殊的双向链表，没有指针，靠entry推算位置） 双向链表adlist (list) 因为双向链表占用的内存比压缩列表要多， 所以当创建新的列表键时， 列表会优先考虑使用压缩列表， 并且在有需要的时候， 才从压缩列表实现转换到双向链表实现。 ziplist 为了节约内存,没有维护双向指针:prev next,而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。（牺牲读取的性能，获得高效的存储空间，指针比entry费空间&lt;时间换空间&gt;） 字段、值比较小时使用。 entry 采用变长编码。 zlentry 源码结构： 12345678910111213141516171819202122//zlentry(entry)结构:typedef struct zlentry &#123; // prevrawlen ：前置节点的长度 // prevrawlensize ：编码 prevrawlen 所需的字节大小 unsigned int prevrawlensize, prevrawlen; // len ：当前节点值的长度 // lensize ：编码 len 所需的字节大小 unsigned int lensize, len; // 当前节点 header 的大小 // 等于 prevrawlensize + lensize unsigned int headersize; // 当前节点值所使用的编码类型 unsigned char encoding; // 指向当前节点的指针 unsigned char *p;&#125; zlentry; 《redis设计与实现》书中配套源码注释对zip结构解析示例: 123456789101112131415161718192021222324252627282930313233/* 空白 ziplist 示例图area |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|size 4 bytes 4 bytes 2 bytes 1 byte +---------+--------+-------+-----------+component | zlbytes | zltail | zllen | zlend | | | | | |value | 1011 | 1010 | 0 | 1111 1111 | +---------+--------+-------+-----------+ ^ | ZIPLIST_ENTRY_HEAD &amp;address ZIPLIST_ENTRY_TAIL &amp; ZIPLIST_ENTRY_END非空 ziplist 示例图area |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|size 4 bytes 4 bytes 2 bytes ? ? ? ? 1 byte +---------+--------+-------+--------+--------+--------+--------+-------+component | zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend | +---------+--------+-------+--------+--------+--------+--------+-------+ ^ ^ ^address | | | ZIPLIST_ENTRY_HEAD | ZIPLIST_ENTRY_END | ZIPLIST_ENTRY_TAIL*/ 连锁更新问题： adlist adlist是标准的双向链表，Node节点包含prev和next指针，可以双向遍历；保存了 head 和 tail 指针，表头和表尾进行插入的复杂度都为 (1) 源码 12345678910111213141516171819202122232425262728293031323334353637383940/* * 双端链表节点 */typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value;&#125; listNode;/* * 双端链表结构 */typedef struct list &#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key); // 链表所包含的节点数量 unsigned long len;&#125; list; 无环： 表头结点的prve和表尾结点的next指向 null。 带链表长度计数器：len 记录了结点数量。 多态：链表使用void*指针来保存值，并且包含 dup,free,match属性来实现特定功能函数。 ziplist -&gt; adlist 转化条件 试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value （默认值为 64 ） ziplist 包含的节点超过 server.list_max_ziplist_entries （默认值为 512 ） 在redis.conf中可以修改12list-max-ziplist-value 64 list-max-ziplist-entries 512 3.2+ 之后，list使用 quickList 作为底层实现: 结合了 adlist和ziplist的优点。 redis6.0.5 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* Node, quicklist, and Iterator are the only data structures used currently. *//* quicklistNode is a 32 byte struct describing a ziplist for a quicklist. * We use bit fields keep the quicklistNode at 32 bytes. * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k). * encoding: 2 bits, RAW=1, LZF=2. * container: 2 bits, NONE=1, ZIPLIST=2. * recompress: 1 bit, bool, true if node is temporarry decompressed for usage. * attempted_compress: 1 bit, boolean, used for verifying during testing. * extra: 10 bits, free for future use; pads out the remainder of 32 bits */typedef struct quicklistNode &#123; struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; //保存的数据 压缩前ziplist 压缩后压缩的数据 unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can&apos;t compress; too small */ unsigned int extra : 10; /* more bits to steal for future usage */&#125; quicklistNode;/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist. * &apos;count&apos; is the number of total entries. * &apos;len&apos; is the number of quicklist nodes. * &apos;compress&apos; is: -1 if compression disabled, otherwise it&apos;s the number * of quicklistNodes to leave uncompressed at ends of quicklist. * &apos;fill&apos; is the user-requested (or default) fill factor. * &apos;bookmakrs are an optional feature that is used by realloc this struct, * so that they don&apos;t consume memory when not used. */typedef struct quicklist &#123; quicklistNode *head; quicklistNode *tail; unsigned long count; /* total count of all entries in all ziplists */ unsigned long len; /* number of quicklistNodes */ int fill : QL_FILL_BITS; //# define QL_FILL_BITS 14 /* fill factor for individual nodes */ unsigned int compress : QL_COMP_BITS; //# define QL_COMP_BITS 14 /* depth of end nodes not to compress;0=off */ unsigned int bookmark_count: QL_BM_BITS;//# define QL_BM_BITS 4 quicklistBookmark bookmarks[];&#125; quicklist;/* Bookmarks are padded with realloc at the end of of the quicklist struct. * They should only be used for very big lists if thousands of nodes were the * excess memory usage is negligible, and there&apos;s a real need to iterate on them * in portions. * When not used, they don&apos;t add any memory overhead, but when used and then * deleted, some overhead remains (to avoid resonance). * The number of bookmarks used should be kept to minimum since it also adds * overhead on node deletion (searching for a bookmark to update). */typedef struct quicklistBookmark &#123; quicklistNode *node; char *name;&#125; quicklistBookmark; quickList也是标准双向链表，有head，tail 每一个quicklistNode 包含 一个ziplist，*zl 压缩链表里存储键值。所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"list","slug":"list","permalink":"https://yantao1995.github.io/tags/list/"}],"author":"Tany"},{"title":"redis底层实现之简单动态字符串 sds","slug":"Untitled","date":"2020-08-23T02:26:00.000Z","updated":"2022-01-20T09:34:15.430Z","comments":true,"path":"2020/08/23/Untitled/","link":"","permalink":"https://yantao1995.github.io/2020/08/23/Untitled/","excerpt":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。","text":"阅读redis书籍《redis设计与实现》笔记。源码版本redis 3.0。 SDS(简单动态字符串) 不直接使用char[]原因: 杜绝缓冲区溢出。 减少修改字符串时带来的内存重分配次数。 字符串拼接append&lt;防止缓冲区溢出&gt;。 字符串截断trim&lt;防止内存泄露&gt;。 类似于golang切片，异同点：sds 内部结构： 123456789struct sdshdr &#123; //记录buf数组中已使用的字节的数量 //等于SDS所保存的字符串长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[];&#125; golang 切片结构： 12345type slice struct &#123; array unsafe.Pointer //引用切片底层的数组 len int //用于限定可读写的元素数量 cap int //表示切片所引用的数组的真实长度&#125; sds如果要计算容量cap： len+free golang切片如果要计算未使用free： cap-len 未使用空间的两种优化策略：空间预分配、惰性空间释放空间预分配 用于优化sds字符串增长操作，可以减少连续执行字符串增长操作所需的内存重分配次数。 策略： 修改后长度小于1MB时：分配的free和len同样大小。比如：修改后sds的len为13字节，那么free也会分配13。此时sds的buf数组长度为13+13+1=27byte。 修改后的长度大于1MB时：分配free为1MB。比如：修改后sds的len变成呃30MB，那么会分配1MB的未使用空间。此时sds的buf数组长度为 30mb+1mb+1byte 。 作用：sds将连续增长n次字符串所需的内存重分配次数从必定n次降低为最多n次。 惰性空间释放 用于优化sds的字符串缩短操作。 策略： 当sds的api需要缩短sds保存的字符串时，并不立即内存重分配，而是使用free将这些字节数量记录起来，等待将来使用。 sds也提供了真正释放sds的未使用空间的api，防止该策略造成内存浪费。 二进制安全与C字符串的比较： C: 字符必须符合某种编码，除末尾外不能包含空字符。所以无法保存图片，音频，视频…二进制数据。 sds: 的api都会以处理二进制的方式来处理sds存放在buf数组的数据。","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"sds","slug":"sds","permalink":"https://yantao1995.github.io/tags/sds/"}],"author":"Tany"},{"title":"linux学习-shell","slug":"linux学习-shell","date":"2020-03-26T10:57:00.000Z","updated":"2022-05-29T08:40:29.777Z","comments":true,"path":"2020/03/26/linux学习-shell/","link":"","permalink":"https://yantao1995.github.io/2020/03/26/linux学习-shell/","excerpt":"linux 学习","text":"linux 学习 入门格式第一行指定解释器,比如指定bash解释器 #!/bin/bash 运行 shell解释器执行【子shell内执行】 bash [脚本名] sh [脚本名] 相对路径或者绝对路径运行【子shell内执行】 【需要x权限】 /root/xxx/xx/[脚本名] ./[脚本名] 不打开子shell启动【当前shell内执行，作用域为当前shell】 source [脚本名] . [脚本名] 不能直接 [脚本名] 启动,因为没有加入到系统环境变量，直接写命令回去环境变量里面找 变量系统预定义变量$HOME,$PWD,$SHELL,$USER 等 自定义变量 定义 变量名=变量值 注意，=号前面不能有空格 默认是字符串类型 变量作用域 子shell变量导出到父shell export [变量名] 不用加$ 如果当前子shell更改了全局变量，只能在当前的shell生效 操作 只读变量 readonly [变量名]=[值] 不能被unset 撤销变量 unset [变量名] 特殊变量 脚本传参,$n表示第n个参数，0表示脚本名称，1-9表示的参数，10以上的需要大括号包住, \\{10\\}，脚本内使用的是双引号,例echo &quot;hello $1&quot; ,单引号则原样输出字符串 获取参数个数 $# 所有参数 ，整体，【用于看所有参数 】$* 所有参数，数组 ，【用于for循环遍历】$@ 最后一次执行命令的返回状态 成功0，失败不为0 $? 【注意】 $* 和 $@ 用于 for 循环中, 需要用 &quot;&quot;包裹才能生效 例如for a in &quot;$*&quot;运算符表达式 【 注意 】(()) 里面可以直接用数学表达式【注意】 [ ] 里面必须是 -lt ,-gt 这种表达式【注意】 表示序列 {} ,示例: {1..100} 表示1到100的序列 写法1：执行运算【就是1和+和2当参数传给expr】 expr 1 + 2 1+2 中间有空格，*有点特殊，需要\\来做转义 写法2：简化上面的 $((运算式)) 或者 $[运算式] 不需要转义了) 命令替换 【获取运算式的结果赋值】 a=$（expr 5 \\* 2） 或者使用 反引号 ` expr 5 \\* 4 ` 条件判断 if 判断 单分支写法1： 123if [ 条件判断 ] ; then 程序fi 写法2： 1234if [ 条件判断 ] then 程序fi 写法3: 输入到一行 12a=15if [ $a -gt 10 ];then echo ok ;fi 注意点：如果存在脚本需要参数 12345#!/bin/bashif [ $1 = xiaoming ]thenecho &quot;welcome $1&quot;fi 在不传参数的情况下，会报错 `./if.sh: line 3: [: =: unary operator expected` 可以优化脚本为： 12345#!/bin/bashif [ &quot;$1&quot;x = &quot;xiaoming&quot;x ]thenecho &quot;welcome $1&quot;fi 多个条件判断: - 方式1： 12a=25if [ $a -gt 18 ] &amp;&amp; [ $a -lt 35 ];then echo OK;fi - 方式2： 使用 `-a并且 -o 或者 ` 来连接 12a=25 if [ $a -gt 18 -a $a -lt 35 ];then echo OK;fi 多分支 else : 1234567#!/bin/bash if [ $1 -gt 20 ] then echo &quot;$1 大于 20&quot; else echo &quot;$1 小于 20&quot; fi elseif : 写成 elif 12345678910#!/bin/bash if [ $1 -gt 20 ] then echo &quot;$1 大于 20&quot; elif [ $1 -eq 20 ] then echo &quot;$1=20&quot; elseecho &quot;$1 小于 20&quot;fi case 语句 case 行尾必须为单词 in ，每个匹配必须有 )作为结尾 双分号 ;; 表示命令序列结束，相当于 break语句 最后的 *)表示默认模式，相当于default 示例： 12345678910111213#!/bin/bashcase $1 in1)echo &quot;值为1&quot;;;2)echo &quot;值为2&quot;;;;*)echo &quot;进入default分支&quot;echo &quot;可以多行命令&quot;;;esac for 循环 基本语法1： 1234for (( 初始值; 循环控制条件; 变量变化 ))do 程序 done 示例: 123456#!/bin/bashfor((a=1;a&lt;=10;a++))do echo &quot;a=$a&quot;done 基本语法2： 1234for 变量 in 值1 值2 值3...do 程序done 示例1： 123456#!/bin/bashfor os in linux windows macdo echo &quot;os=$os&quot;done 示例2： 1234567#!/bin/bashfor i in &#123;1..100&#125;do sum=$[ $sum + $i]doneecho $sum while 循环语法: 1234while [条件表达式] 可以使用 (()) ,也可以使用 []do 程序done 示例: 1234567#!/bin/basha=1while [ $a -lt 10 ]do echo &quot;a=$a&quot; a=$[ $a+1]done 写法2：【使用let】【+=前面不能有空格】 1234567#!/bin/bash a=1while [ $a -lt 10 ]do let sum+=a let a++done read读取控制台输入 语法 read [-p指定读取值时的提示符,-t指定读取等待时间(不加一直等待)] [参数(指定读取值的变量名)] 示例： 123#!/bin/bashread -t 10 -p &quot;请输入名字:&quot; nameecho &quot;welcome $name&quot; 函数系统函数 命令替换，脚本内调用 $(命令+参数) 例子：函数接收文件名，然后自定义名称加上时间戳 123#!/bin/bashfilename=&quot;$1&quot;_log_$(date +%s)echo $filename basename : 取文件名 basename [文件名] [去掉后缀] 得到文件名 dirname : 获取路径的文件夹路径 dirname [路径] 得到当前文件夹路径 自定义函数 语法： 12345[function] funname [()] //function和后面中括号里面的小括号都可以省略&#123; // 这个大括号可以放上面一行 程序; [return int;] //可以省略&#125; 注意 调用前必需声明 函数返回值，只能通过 $? 来获得，返回值只能为 0-255 示例1：接收返回值,只能返回0-255的值 123456789#!/bin/bashfunction add()&#123; s=$[$1+$2] return $s;&#125;read -p &quot;输入第一个参数:&quot; aread -p &quot;输入第二个参数:&quot; badd $a $becho &quot;和:&quot;$? 示例2：命令替换 12345678910#!/bin/bashfunction add()&#123; s=$[$1+$2] echo $s&#125;read -p &quot;输入第一个参数:&quot; aread -p &quot;输入第二个参数:&quot; bsum=$(add $a $b)echo &quot;和:&quot;$sumecho &quot;和的平方:&quot;$[$sum * $sum] 正则 字符 ^ 匹配一行的开头,例 ^a ,会匹配所有以a开头的行 字符 $ 匹配一行的结束,例 t$,会匹配所有以t结尾的行，如果要对本符号进行匹配，则需要转义 ‘\\$’,必须用单引号 字符 . 匹配一个任意字符,例子 r..t,会匹配出 root，ra/t这种 字符 * 上一个字符出现0-n次,例子 .*，会匹配任意字符串 字符区间 [] ,表示范围内任意一个字符都可以,例子 [6,8]匹配6或者8，例子 [6-8]匹配6到8，例子 [6-8,10-12]匹配6到8,或者10到12 grep使用-E参数表示开启支持扩展的正则，可以使用{n}表示精确的能匹配到的个数,例如，匹配手机号 grep ^1[3,4,5,7,8][0-9]{9}$ 文本处理cut 文件切割 从文件中剪切字节，字符和字段并输出，主要分隔列 使用:cut [-f指定提取第几列,-d指定列的分隔符,默认制表符\\t,-c按字符切割后面跟n表示提取第n列] 技巧: cur -f 6- 表示 第6到末尾列 例子，获取所有ip: ifconfig | grep netmask | cut -d &quot; &quot; -f 10 因为ip在netmask那一行，所以用来筛选，切割时，前面有空格，所以第10列 awk 强大的文本分析，默认以空格切割基本用法: 1awk [-F指定分隔符，-v赋值一个用户定义变量] ‘/pattern1/&#123;action1&#125; /pattern2/&#123;action2&#125;... ’ filename pattern: 表示 awk在数据中查找的内容，就是匹配模式 action: 在找到匹配内容时所执行的一系列命令,类似于函数，可以读参数和变量 例子1，获取root用户登录,如果使用cut 1cat /etc/passwd | grep ^root | cut -d &quot;:&quot; -f 7 如果使用akw 1cat /etc/passwd | awk -F : &apos;/^root/&#123;print $7&#125;&apos; 例子2,输出多列 1cat /etc/passwd | awk -F : &apos;/^root/&#123;print $6&quot;,&quot;$7&#125;&apos; //可以指定中间的打印分隔符，还可以打印多个列 例子3，只显示第1列和第7列，逗号风格，并且在第一行增加列名”user,shell”，并且在最后一行添加 “at the end”使用 BEGIN 和 END 来操作 1cat /etc/passwd | awk -F : &apos;BEGIN&#123;print &quot;user,shell&quot;&#125;&#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;at the end&quot;&#125;&apos; 例子4：定义变量 ,变量引用不需要加 $ 符号 1cat /etc/passwd | awk -v i=1 -F &quot;:&quot; &apos;&#123;print $3+i&#125;&apos; 内置变量: FILENAME 文件名 NR 已读的记录数(行号) NF 浏览记录的域的个数(切割后,列的个数) 例子：输出3个信息 1awk -F &quot;:&quot; &apos;&#123;print &quot;文件名:&quot;FILENAME &quot;行号:&quot;NR &quot;列数:&quot;NF&#125;&apos; /etc/passwd 例子：输出空行 12ifconfig | grep -n ^$ifconfig | awk &apos;/^$/&#123;print NR&#125;&apos; 综合应用发送消息 使用write可以给其他终端发送消息，只要对方打开了消息接收功能 查看是否打开了消息接收功能who -T ，显示的列分别为 用户名| + (表示打开) | 终端号 如果没打开，可以使用 mesg n 打开终端 使用命令 write [用户名] [终端号] 即可以发送消息 写一个发送消息的脚本 易错点: 变量赋值=前后不能有空格 if后面的 [ ] 判断条件和方括号必须 空格 分开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/bash#查看用户是否登录send_user=$(who | grep -i -m 1 $1 | awk &apos;&#123;print $1&#125;&apos; )if [ -z $send_user ]then echo &quot;用户名为空&quot; echo &quot;脚本退出&quot; exitfi# 查看用户是否开启消息功能is_allowed=$(who -T | grep -i -m 1 $1 | awk &apos;&#123;print $2&#125;&apos; )if [ $is_allowed != &quot;+&quot; ]then echo &quot;$1没有开启消息功能&quot; echo &quot;脚本退出&quot; exitfi#确认是否有消息发送if [ -z $2 ]then echo &quot;没有消息发送&quot; echo &quot;脚本退出&quot; exitfi# 获取消息messages=$(echo $* | cut -d &quot; &quot; -f 2-)# 获取用户的终端user_terimal=$(who -T | grep -i -m 1 $1 | awk &apos;&#123;print $3&#125;&apos; )# 输出看看参数正确不echo &quot;user:&quot;$send_userecho &quot;terimal:&quot;$user_terimalecho &quot;messages:&quot;$messages# 发送消息echo $messages | write $send_user $userterimalif [ $? = 0 ]then echo &quot;发送成功&quot;else echo &quot;发送失败&quot;fiexit","categories":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/tags/linux/"}],"author":"Tany"},{"title":"linux学习-bash","slug":"linux学习-bash","date":"2020-03-24T10:57:00.000Z","updated":"2022-05-29T08:39:47.063Z","comments":true,"path":"2020/03/24/linux学习-bash/","link":"","permalink":"https://yantao1995.github.io/2020/03/24/linux学习-bash/","excerpt":"linux 学习","text":"linux 学习 扩展在线帮助文档man man [命令的名称]type [命令] 判断命令类型 ,内部命令需要 man -f [内部命令] 内部命令 cd ,exit 外部命令 ps,ls ….. helphelp [内部命令]只能查看内部命令 –help[外部命令] –help只能查看外部命令 常用普通pwd,ls,cd,mkdir,rmdir,touch,cp,rm,mv,catmore,less,echo,alias,head,tail,history,date,sort 输入重定向和追加: &gt; 覆盖 , &gt;&gt; 追加 ln : 仅删除软连接 rm [名] , 删除连接文件夹内文件 rm [名]/ ， [-s 不加就是创建硬链接，底层会复制一份inode信息]常用易忘命令参数sort1234-k [n] //按第n列升序-r //降序-n //按数值大小排序-t [分隔字符] //指定分隔字符 管理账户用户创建用户 useradd [-g [组名]] [用户名]更改密码 passwd [用户名]查看用户是否存在 id [用户名]切换用户 su [用户名]当前用户 最原始的会话 who am i , 目前的会话 whoami赋予root权限执行命令 sudo [命令] 需要先将用户权限添加至 /etc/sudoers 用户权限 用户名 ALL=(ALL) ALL 组权限 %组名 ALL=(ALL) ALL [NOPASSWD:all （可选项，用于跳过输密码） ] 组 ： 集中化管理用户用户删除 userdel [-r:是否删个人目录] [用户名]用户组 配置文件 /etc/group新建组 groupadd [名]修改用户所在组 usermod -g [组名] [用户名]修改组的组名 groupmod -n [新组名] [旧组名]删除组 groupdel [名] 权限 chmod 修改文件查看 ll 或者 ls -l - 普通文件 d 文件夹 l 链接文件读写运行 rwx , 所属用户 | 组用户 | 其他用户 删除文件，需要对文件父目录有w写权限 进入目录，需要有对该文件的x运行权限 修改权限 chmod [-R (针对目录下的所有文件)] [ugoa (用户/组/其他用户/全部)] [+-=] [rwx] 文件/目录 chown 改变所有者 chown [-R (针对目录向下递归)] [目标用户] [文件/目录] chgrp 改变所属组 chgrp [目标组] [文件/目录] 搜索 find 找文件/目录 find [ （路径匹配） (-name 名字) (-user 所属用户) （-size 文件大小 [ +2M（大于2M）]）] [文件名] locate 速度快，在文件系统数据库内找 locate [名]，每天更新，也可以手动更新数据库 updatedb which 查找命令位置, which [命令] grep 过滤查找 grep [-n 显示行号] [关键字] [文件名] wc 统计词数 wc [文件名] 结果 x1 x2 x3 分别为 行数，单词数，字节数 压缩解压 gz压缩解压 gzip/gunzip [文件名] 不保留源文件，只能压缩文件，不能压缩目录 z压缩解压 zip [-r 压缩目录] unzip [-d 存放目录] 要保留源文件，可以压缩目录 tar 打包归档 tar [-c 产生.tar文件, -v 显示详细信息, -f 指定压缩后的文件名，-z 打包同时压缩(使用的gzip)，-x解包.tar文件,-C指定解压目录] 压缩 tar -zcvf [文件名 ] [....文件] 解压 tar -zxvf [文件名 ] [-C] [指定目录] 磁盘 tree 显示目录树 安装yum install tree 显示当前文件本身的大小 ls -lh du查看当前目录占用所有的大小 du [-h显示单位大小,-a不仅查看子目录，还有文件，-c结尾额外显示总和，-s只显示总和，--max-depth=n指定统计子目录深度的第n层] [目录/文件] df 查看磁盘剩余空间 df [-h 显示单位大小] mount/umount 挂载/卸载 mount [-t 文件系统类型，-rw 读写方式，-ro只读] [设备位置] [挂载点] 设置开机启动自动挂载，修改文件 /etc/fstab 里面新增一行挂载内容 fdisk分区 fdisk [-l 查看分区详情，-n添加一个分区] lsblk 查看设备挂载情况 lsblk [-f 查看设备详细情况，文件情况] 内存 free 查看内存使用情况 free [-h 显示单位大小] 系统管理 ps 查看进程 只显示当前终端用户的 ps 参数带 - 的表示标志unix风格，不带-的是BSD风格 一般想看资源占用率 ps aux 想看进程父子关系 ps -ef ps [a带终端所有用户进程，x当前用户的所有进程，u面向用户友好的显示风格] 多显示了内存和cpu使用 ps[-e所有进程,-u某个用户关联的进程,-f完整格式的进程列表] 多显示了父进程ppid kill 终止进程 【慎用 killall 终止所有与该进程有关的进程】kill [-(1-62)信号值【一般-9 SIGKILL】，-l查看信号值列表] [进程id] pstree 进程树 ps [-p 查看pid ，-u 进程所属] top 实时查看进程状态 top [-d秒数 指定每隔几秒更新，-i不显示闲置或僵死进程，-p指定进程id来监控某个进程] 功能 u 筛选user，k终止进程 netstat 显示网络状态 netstat [-a 显示所有list和socket，-n不显示别名能显示数字的全部显示数字，-l仅列出监听的服务状态，-p显示哪个进程在调用] 常用查看进程网络信息 netstat -anp 常用查看网络端口 netstat -nlp crontab 系统定时任务,开启守护进程 systemctl start crond 命令行 crontab [-e 编辑任务，-l查询任务， -r删除当前用户的所有任务] 编辑 * * * * * 分别表示 分钟，小时，天，月，星期几","categories":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/tags/linux/"}],"author":"Tany"},{"title":"linux学习-vim","slug":"linux学习-vim","date":"2020-03-22T10:57:00.000Z","updated":"2022-05-29T08:39:31.194Z","comments":true,"path":"2020/03/22/linux学习-vim/","link":"","permalink":"https://yantao1995.github.io/2020/03/22/linux学习-vim/","excerpt":"linux 学习","text":"linux 学习 常用命令模式 撤销 u 复制 y 一个单词 yw 2个单词 y2w 到行尾 y$ 复制到行首 `y0 复制整行yy 复制2行2yy` 粘帖 p 一次 p 2次 2p 删除 d 光标所在字符 x 光标左边 X 1行 dd 2行 2dd 删除到文本开头 dgg 删除到文本结尾 dG 一个单词(光标到右边空格) dw 整个单词 daw 从光标到末尾 d$ 从光标到行首 d0 行移动 移动到 页面70%的行 70% 当前屏幕页首 H 当前屏幕页中 M 当前屏幕页尾 E 文件首 gg 文件第二行 2G 第三行 3G 两个 ` 移动到前一个光标位置 列移动 当前第二列 2| 第三列 3| 命令行模式 显示行号 set nu 消除行号 set nonu 查找 正向 /str 反向 ?str n 查找下一个 shift + n 查找上一个 noh 取消高亮 替换 替换当前光标所在行第一个词s/被替换词/替换词 替换当前光标所在行的所有词s/被替换词/替换词/g 替换每一行的第一个词%s/被替换词/替换词 替换每一行的所有词%s/被替换词/替换词/g","categories":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/tags/linux/"}],"author":"Tany"},{"title":"linux学习-网络","slug":"linux学习-网络","date":"2020-03-21T10:57:00.000Z","updated":"2022-05-29T08:44:07.347Z","comments":true,"path":"2020/03/21/linux学习-网络/","link":"","permalink":"https://yantao1995.github.io/2020/03/21/linux学习-网络/","excerpt":"linux 学习","text":"linux 学习 配置动态ip修改为静态ip 一定要先启用网卡开关 ONBOOT=yes 配置文件 /etc/sysconfig/network-script/ifcfg-ens33 修改 dhcp 为 static 添加配置项 IPADDR = ip 添加网关 GATEWAY = ip 添加dns1 = dns （可以指定多个dns,例子 dns1 dns2 dns3） 重启服务 ： service network restart 配置主机名查看当前主机名：hosename 配置文件 /etc/hostname (需要重启) 直接写入名字 hostnamectl set-hostname xxx （即时生效） 配置hosts映射关系配置文件 /etc/hosts - 直接填入`ip hostname`配置完成后如果无法解析域名，需要修改dns 修改NetworkManager.conf 配置文件 123vi /etc/NetworkManager/NetworkManager.conf#在[main]中添加dns=no 修改resolv.conf配置文件 123vim /etc/resolv.conf #添加dns nameserver 114.114.114.114 重启 systemctl restart NetworkManager","categories":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/tags/linux/"}],"author":"Tany"},{"title":"linux学习-基本","slug":"linux知识","date":"2020-03-20T10:57:00.000Z","updated":"2022-05-29T08:35:35.263Z","comments":true,"path":"2020/03/20/linux知识/","link":"","permalink":"https://yantao1995.github.io/2020/03/20/linux知识/","excerpt":"linux 学习","text":"linux 学习 $开头的一些常用特殊指令123456$#：传入的参数数量$@：传入的参数列表$0,$1,...：传入的第 i 个参数!$ 或者 $_：上一个命令的最后一个参数$?：上一条命令返回的状态码$!：Shell 最后运行的后台 Process 的 PID 软件包管理rpm 红帽软件包管理工具，类似于windows的setup.exe缺点就是各种依赖关系不好处理，a依赖b，b依赖c这种 操作rpm [-qa 查询安装的所有软件包，-e卸载，-i 安装(-v 显示详细信息，-h显示进度条) --nodeps 不检查依赖强制操作 ] yum 基于rpm管理，更好用，一键操作 自动处理依赖关系 操作 yum [-y所有都yes，install 安装，update 更新，check-update 检测是否更新，remove删除，list显示信息，clean清理过期缓存，deplist显示所有依赖] 修改yun网络源 文件/etc/yum.repos.d 目录下 CentOs-Base.repo文件 常用服务管理.target 一组服务的集合.service 单个服务 centos6service 服务名 [restart | stop | start | status]所在目录 /etc/init.d/ centos7 (也兼容 centos6 的方式)systemctl [start |stop | restart | status|disable] 服务名所在目录 /usr/lib/systemd 启动级别 3 multi-user.target 多用户控制台界面 5 graphical.target 多用户图形界面 查看默认运行级别 systemctl get-default设置默认运行级别 systemctl set-default 运行级别 切换运行级别 init 3/5","categories":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yantao1995.github.io/tags/linux/"}],"author":"Tany"},{"title":"编码练习","slug":"编码练习","date":"2020-01-01T03:38:00.000Z","updated":"2021-12-21T09:54:49.524Z","comments":true,"path":"2020/01/01/编码练习/","link":"","permalink":"https://yantao1995.github.io/2020/01/01/编码练习/","excerpt":"","text":"力扣第5题 （最长回文子串） 官方难度 中等，通过率 27.9% 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 暴力破解，nopass，字符串足够长就会超时 123456789101112131415161718192021222324func longestPalindrome(s string) string &#123; if len(s) == 0 &#123; return &quot;&quot; &#125; if len(s) == 1 &#123; return s &#125; for lns := len(s); lns &gt; 1; lns-- &#123; //字串长度 for i := 0; i &lt;= len(s)-lns; i++ &#123; //移动游标 flag := true for j := i; j &lt; lns/2+i; j++ &#123; //字串比较 fmt.Println(&quot;lns&quot;, lns, &quot;i&quot;, i, &quot;start&quot;, j, &quot;end&quot;, lns+2*i-j-1) if s[j] != s[lns+2*i-j-1] &#123; //区间 flag = false break &#125; &#125; if flag &#123; return s[i : lns+i] &#125; &#125; &#125; return string(s[0])&#125; 力扣第4题 （寻找两个有序数组的中位数） 官方难度 困难，通过率 36.4% 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 pass 1234567891011121314151617181920212223242526272829303132333435363738394041424344func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; ll := (len(nums1) + len(nums2)) - 2 mid := ll / 2 if ll%2 == 1 &#123; mid = ll/2 + 1 &#125; if ll%2 == -1 &#123; mid = 0 &#125; mid1 := mid + 1 midnum, mid1num := 0, 0 temp, count := 0, 0 fmt.Println(&quot;len(num1):&quot;, len(nums1), &quot;len(nums2):&quot;, len(nums2), &quot;mid:&quot;, mid, &quot;mid1:&quot;, mid1) for i, j := 0, 0; ; &#123; devided1, devided2 := 0, 0 if i &lt; len(nums1) &#123; devided1 = temp - nums1[i] &#125; if j &lt; len(nums2) &#123; devided2 = temp - nums2[j] &#125; if (devided1 &gt;= devided2 &amp;&amp; i &lt; len(nums1)) || j &gt;= len(nums2) &#123; //差值小 temp = nums1[i] i++ &#125; else &#123; temp = nums2[j] j++ &#125; if count == mid &#123; midnum = temp if ll%2 == 1 || (mid == 0 &amp;&amp; ll%2 == -1) &#123; return float64(temp) &#125; &#125; if count == mid1 &#123; mid1num = temp break &#125; fmt.Println(i, &quot;i _ j&quot;, j, &quot;temp:&quot;, temp, &quot;count:&quot;, count, &quot;devide1:&quot;, devided1, &quot;devide2:&quot;, devided2) count++ &#125; fmt.Println(midnum, &quot;-&quot;, mid1num) return (float64(midnum) + float64(mid1num)) / 2&#125; 力扣第3题 （无重复字符的最长子串） 官方难度 中等，通过率 32.3% 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 暴力破解pass 123456789101112131415161718192021func lengthOfLongestSubstring(s string) int &#123; length := 0 for i := 0; i &lt; len(s); i++ &#123; currentlength := 1 sli := append([]byte&#123;&#125;, byte(s[i])) for j := i + 1; j &lt; len(s); j++ &#123; for _, v := range sli &#123; if byte(v) == s[j] &#123; goto comehere &#125; &#125; currentlength++ sli = append(sli, byte(s[j])) &#125; comehere: if length &lt; currentlength &#123; length = currentlength &#125; &#125; return length&#125; 力扣第2题 （链表结点数字相加） 官方难度 中等，通过率 36.3% 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 pass： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var node1, node2 []int for l1 != nil || l2 != nil &#123; if l1 != nil &#123; node1 = append(node1, l1.Val) l1 = l1.Next &#125; else &#123; node1 = append(node1, 0) &#125; if l2 != nil &#123; node2 = append(node2, l2.Val) l2 = l2.Next &#125; else &#123; node2 = append(node2, 0) &#125; &#125; fmt.Println(node1) fmt.Println(node2) length := len(node2) if len(node1) &gt; len(node2) &#123; length = len(node1) &#125; kflag := 0 for i := 0; i &lt; length; i++ &#123; k := node1[i] + node2[i] + kflag node1[i] = (k % 10) if k &gt;= 10 &#123; kflag = 1 &#125; else &#123; kflag = 0 &#125; &#125; if kflag == 1 &#123; node1 = append(node1, 1) &#125; fmt.Println(node1) var head *ListNode = &amp;ListNode&#123;Val: node1[0]&#125; p := head for k, v := range node1 &#123; if k != 0 &#123; ln := ListNode&#123; Val: v, &#125; p.Next = &amp;ln p = p.Next &#125; &#125; return head&#125; 力扣第1题 （数组两数之和） 官方难度 简单，通过率 47.2% 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] pass： 12345678910111213func twoSum(nums []int, target int) []int &#123; ret := make([]int,2) for i:=0;i&lt;len(nums);i++&#123; ret[0] = i for j := i+1 ;j &lt; len(nums);j++&#123; if nums[i] + nums[j] == target&#123; ret[1] = j return ret &#125; &#125; &#125; return ret&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"}],"author":"Tany"},{"title":"生成指定长度的字符串","slug":"生成指定长度的字符串","date":"2019-11-26T11:57:00.000Z","updated":"2019-11-26T12:11:33.708Z","comments":true,"path":"2019/11/26/生成指定长度的字符串/","link":"","permalink":"https://yantao1995.github.io/2019/11/26/生成指定长度的字符串/","excerpt":"在微信支付及其他很多场景下，都需要生成指定长度的字符串。而golang在很多时候生成的随机数其实是伪随机数，只在一个序列下保持随机。","text":"在微信支付及其他很多场景下，都需要生成指定长度的字符串。而golang在很多时候生成的随机数其实是伪随机数，只在一个序列下保持随机。 生成指定长度的字符串(相邻字符不重复) 使用了当前时间的时间戳纳秒作为随机数种子。 生成的字符范围:a-z,A-Z 很多时候由于计算机速度过快，在同一纳秒下生成了多个字符，导致结果类似 aaaddddwwwwwsssssddddddddeeeeeeeeegggggggssssss这样的随机序列，所以在此对数据进行里去重。 简单一点可以使 time.Sleep()来休眠一定时间，来让随机数种子不一样，但这会导致效率低下。在这儿将即将写入字符串的字符与前一个做比较，相同的则不写入，保证了相邻的两个字符不相同。123456789101112131415161718192021222324252627282930313233func NonceStrCreate(len int) string &#123; if len &lt;= 0 &#123; return &quot;&quot; &#125; var bhint int var c, cc rune var buffer bytes.Buffer var length int = 0 for &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) if r.Intn(10) &gt;= 5 &#123; bhint = r.Intn(4) + r.Intn(23) c = rune(97 + bhint) &#125; else &#123; bhint = r.Intn(4) + r.Intn(23) c = rune(65 + bhint) &#125; if length == 0 &#123; buffer.WriteString(string(c)) cc = c length = 1 &#125; if cc != c &amp;&amp; length &gt; 0 &#123; buffer.WriteString(string(c)) cc = c length++ &#125; if length == len &#123; break &#125; &#125; return buffer.String()&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"}],"author":"Tany"},{"title":"没事干瞎写系列之x的n次方","slug":"没事干瞎写系列之a的b次方","date":"2019-11-25T13:28:00.000Z","updated":"2019-11-25T13:47:35.012Z","comments":true,"path":"2019/11/25/没事干瞎写系列之a的b次方/","link":"","permalink":"https://yantao1995.github.io/2019/11/25/没事干瞎写系列之a的b次方/","excerpt":"在网上突然看到别人再问2的10次方是几位数，然后就瞎写了一下，在此做笔记记录一下。用的是最蠢的循环","text":"在网上突然看到别人再问2的10次方是几位数，然后就瞎写了一下，在此做笔记记录一下。用的是最蠢的循环 比如2的100次方，-2的100次方。 因为计算机的存储数的位数有限制，所以下面采用了[]int切片来存储每一位数字。 tips:计算机中，比如想算2^10000，计算机会先算2^5000，再算一次平方，即两个数的乘法。而为了计算2^5000，计算机会先算2^2500再算一次平方。这个算法叫快速幂算法。 但是这儿采用了最蠢的循环。 a: -10&lt;a&lt;10 的整数。 b: b&gt;=0 整数 12345678910111213141516171819202122232425262728//IndexMult a的b次方,b为非负整数func IndexMult(a, b int) ([]int, string) &#123; result := make([]int, 1) symbol := &quot;+&quot; if a &lt; 0 &#123; //正负 if b%2 != 0 &#123; symbol = &quot;-&quot; a = 0 - a &#125; &#125; result[0] = a if b == 0 &#123; result[0] = 1 &#125; for j := 0; j &lt; b-1; j++ &#123; nextFlag := 0 for i := 0; i &lt; len(result); i++ &#123; r := a*result[i] + nextFlag nextFlag = r / 10 low := r % 10 result[i] = low &#125; if nextFlag != 0 &#123; result = append(result, nextFlag) &#125; &#125; return result, symbol&#125; 测试一波(输出顺序从尾巴到头部): 1234567func main()&#123; mult, symbol := IndexMult(2, 10000) fmt.Printf(&quot;%s&quot;, symbol) for i := len(mult) - 1; i &gt;= 0; i-- &#123; fmt.Printf(&quot;%d&quot;, mult[i]) &#125;&#125; 输出时。从切片的尾部向头部输出就是正确的数字序列。因为数字的最高位是存储在切片的尾部的。","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"}],"author":"Tany"},{"title":"go协程并发channel通信","slug":"go协程并发处理","date":"2019-11-20T12:22:00.000Z","updated":"2019-11-20T13:24:36.615Z","comments":true,"path":"2019/11/20/go协程并发处理/","link":"","permalink":"https://yantao1995.github.io/2019/11/20/go协程并发处理/","excerpt":"在go语言中文网上看到一个面经，其中的一道题","text":"在go语言中文网上看到一个面经，其中的一道题 协程间的通信 启动两个协程, 一个输出 1,3,5,7…99, 另一个输出 2,4,6,8…100 最后 STDOUT 中按序输出 1,2,3,4,5…100 因为在main函数中，为了让main函数等待协程执行，所以使用了sync.WaitGroup来等待协程执行完成 最终优化后能正确输出的代码：12345678910111213141516171819 var wg sync.WaitGroup ch := make(chan int) ch2 := make(chan int) wg.Add(2) go func() &#123; for i := 1; i &lt;= 50; i++ &#123; fmt.Printf(&quot;%d\\t&quot;, &lt;-ch) ch2 &lt;- 2 * i &#125; wg.Done() &#125;() go func() &#123; for j := 1; j &lt;= 50; j++ &#123; ch &lt;- 2*j - 1 fmt.Printf(&quot;%d\\t&quot;, &lt;-ch2) &#125; wg.Done() &#125;() wg.Wait() 输出： 11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 —————————————————————————————————————— 原始的错误代码 最开始写的代码是这样的：123456789101112131415161718var wg sync.WaitGroup ch := make(chan int) wg.Add(2) go func() &#123; for i := 1; i &lt;= 50; i++ &#123; fmt.Printf(&quot;%d\\t&quot;, &lt;-ch) &#125; wg.Done() &#125;() go func() &#123; for j := 1; j &lt;= 100; j++ &#123; ch &lt;- j j++ fmt.Printf(&quot;%d\\t&quot;, j) &#125; wg.Done() &#125;() wg.Wait() 执行后的结果： 12 1 3 4 6 5 7 8 10 9 11 12 14 13 15 16 18 17 19 20 22 21 23 24 26 25 27 28 30 29 31 32 34 33 35 36 38 37 39 40 42 41 43 44 46 45 47 48 50 49 51 52 54 53 55 56 58 57 59 60 62 61 63 64 66 65 67 68 70 69 71 72 74 73 75 76 78 77 79 80 82 81 83 84 86 85 87 88 90 89 91 92 94 93 95 96 98 97 99 100 分析：由于使用的是无缓冲通道，当协程并发执行时,在第二个go func(){} 中ch &lt;- j将j的值传入通道后,第一个go func(){}会进入非阻塞状态，此时第二个go func(){}直到下次给通道赋值前。两个协程都处于无限制的并发状态，导致了出现的2 1 3 4 6 5的输出可能性。 第一次优化 在第二个协程中的time.Sleep(10)加入等待时间。让第二个协程在通知第一个协程之后，保证第一个协程的fmt.Printf(&quot;%d\\t&quot;, &lt;-ch)能先打印出信息。当然缺点很明显。这样就平白无故的浪费了 10 x 50 毫秒的时间。 12345678910111213141516171819var wg sync.WaitGroup ch := make(chan int) wg.Add(2) go func() &#123; for i := 1; i &lt;= 50; i++ &#123; fmt.Printf(&quot;%d\\t&quot;, &lt;-ch) &#125; wg.Done() &#125;() go func() &#123; for j := 1; j &lt;= 100; j++ &#123; ch &lt;- j time.Sleep(10) j++ fmt.Printf(&quot;%d\\t&quot;, j) &#125; wg.Done() &#125;() wg.Wait() 输出：1 -&gt; 100 正常输出 第二次优化 去掉了time.Sleep()在第一个协程和第二个协程中也使用channel通道来传递信息，保证两边按顺序输出。123456789101112131415161718192021 var wg sync.WaitGroup ch := make(chan int) ch2 := make(chan int) wg.Add(2) go func() &#123; for i := 1; i &lt;= 50; i++ &#123; fmt.Printf(&quot;%d\\t&quot;, &lt;-ch) ch2 &lt;- 1 //通知另一个 协程 处理完成 &#125; wg.Done() &#125;() go func() &#123; for j := 1; j &lt;= 100; j++ &#123; ch &lt;- j j++ &lt;-ch2 //等待另一个协程处理完成 fmt.Printf(&quot;%d\\t&quot;, j) &#125; wg.Done() &#125;() wg.Wait() 输出：1 -&gt; 100 正常输出 最后优化了变量的使用，代码更清晰。第一步操作","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"},{"name":"channel","slug":"channel","permalink":"https://yantao1995.github.io/tags/channel/"}],"author":"Tany"},{"title":"go踩坑日记","slug":"go日常","date":"2019-10-24T14:38:00.000Z","updated":"2020-07-23T02:24:13.794Z","comments":true,"path":"2019/10/24/go日常/","link":"","permalink":"https://yantao1995.github.io/2019/10/24/go日常/","excerpt":"golang日常遇到的一些坑或者小技能实录","text":"golang日常遇到的一些坑或者小技能实录 defer链式函数的传递调用1234567891011121314type Slice []intfunc NewSlice() Slice &#123; return make(Slice, 0)&#125;func (s *Slice) Add(elem int) *Slice &#123; *s = append(*s, elem) fmt.Print(elem) return s&#125;func main() &#123; s := NewSlice() defer s.Add(1).Add(2).Add(4) s.Add(3)&#125; 1输出 1234 本以为输出3124，或者3421。结果输出1234。 原因：defer只能执行一个函数。 在defer后是一个链式函数而且defer是一个压栈的输入，4被defer执行，1和2直接被执行，所以打印1234。 golang知识体系 点击查看这张图 内建函数new与make 二者都是用于内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才才可以对他们进行操作。 对切片进行遍历赋值 如果不是append直接追加赋值，用索引下标方式赋值一定要先初始化分配空间123456789 a := []int&#123;1,2,3&#125;var b []struc = make([]struc, len(a)) for k, _ := range a &#123; b[k].Name = &quot;123&quot; fmt.Println(b[k]) &#125;type struc struct &#123; Name string&#125; 协程并发执行等待123456789var wg sync.WaitGroupfor i:=0:i&lt;=10;i++ &#123; wg.Add(1) go func() &#123; defer wg.Done() //。。。此处执行任务代码 &#125;() &#125;wg.Wait() wg.Wait()会等待所有的协程结束，才会继续执行下去。其中 wg.Add(number)number可以为2，3等等其他值。取决于下面的协程数量，但是每Add()开启一个协程，必须对应一个 Done()关闭。 当天0点的时间戳123t := time.Now() tm1 := time.Date(t.Year(), t.Month(), t.Day()-1, 0, 0, 0, 0, t.Location()) tm2 := tm1.AddDate(0, 0, 1) 切记 t.day() -1 ，否则是明天的0点时间戳 常用类型转换123int转string strconv.Itoa() //int float string 互转用strconv包[]byte/byte 转string string([]byte/byte) interface&#123;&#125;转 string interface&#123;&#125;.(string) 切片元素删除123456789101112131415t := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;&#125; for i := 0; i &lt; len(t); i++ &#123; if t[i] == &quot;c&quot; || t[i] == &quot;c&quot; || t[i] == &quot;d&quot; &#123; // 将删除点前后的元素连接起来 fmt.Println(i, t[i]) t = append(t[:i], t[i+1:]...) i-- &#125; fmt.Println(i) &#125; fmt.Println(&quot;----------&quot;) for i := 0; i &lt; len(t); i++ &#123; fmt.Println(i, t[i]) &#125; 元素删除后使用i- - 将遍历位置切换到连接点。否则会出panic: index of range。 字符串比较1strings.Compare(a, b) strings.Compare() 效率比 == 效率高 内层结构体嵌套1234567891011121314151617func main()&#123; var s Student s.Stu = make([]Stu2, 0) //初始化 str, _ := json.Marshal(&amp;s) fmt.Println(string(str))&#125;type Student struct &#123; Name string ID int Stu []Stu2&#125;type Stu2 struct &#123; N2 int N3 int&#125; 在将结构体内嵌套的切片结构体转成json数据时，如果不用make初始化:s.Stu = make([]Stu2, 0)转换后的json会变成{&quot;Name&quot;:&quot;&quot;,&quot;ID&quot;:0,&quot;Stu&quot;:null} 使用make初始化之后json为： {&quot;Name&quot;:&quot;&quot;,&quot;ID&quot;:0,&quot;Stu&quot;:[]} windows下使用阿里云代理包下载12$env:GO111MODULE=&quot;on&quot;$env:GOPROXY=&quot;https://mirrors.aliyun.com/goproxy/&quot; Inf 阶码溢出 inf前面带+-符号的，代码高位溢出。小数点位后面无限大。 解决方法：使用fmt.Sprintf(“%0.2f”,浮点数) 输出一个字符串的固定位的浮点数，在把这个字符串转为float。 nohup文件过大 清空：方法1 cp /dev/null nohup.out ，方法2 cat /dev/null &gt; nohup.out json操作 因为原生包上操作json需要使用struct来映射到对应的属性上去，所以可以利用两个包来直接操作json的[]byte数组 set的相关操作：https://github.com/tidwall/sjson get的相关操作：https://github.com/json-iterator/go 滴滴平台的包","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"},{"name":"go日常","slug":"go日常","permalink":"https://yantao1995.github.io/tags/go日常/"}],"author":"Tany"},{"title":"go-redis入门及踩坑日记","slug":"go-redis入门及小坑","date":"2019-10-22T14:40:00.000Z","updated":"2019-11-20T12:07:02.136Z","comments":true,"path":"2019/10/22/go-redis入门及小坑/","link":"","permalink":"https://yantao1995.github.io/2019/10/22/go-redis入门及小坑/","excerpt":"golang的非关系型数据库redis的踩坑实录","text":"golang的非关系型数据库redis的踩坑实录 redis命令中的setex key value time,获取ttl 成功例：1234567891011totaltime := taskTimeOut + taskTimeOutErr //预设时间+网络误差时间，初值10 rds.SetNX(&quot;aatestNXTTL&quot;, &quot;xxxxx&quot;, time.Duration(totaltime*1e9)) ttl, _ := rds.TTL(&quot;aatestNXTTL&quot;).Result() for i := 0; i &lt; 11; i++ &#123; ttldecimal := ttl.Nanoseconds() / 1e9 go func(ttldecimal int64) &#123; fmt.Println(ttldecimal) &#125;(ttldecimal) time.Sleep(time.Second) ttl, _ = rds.TTL(&quot;aatestNXTTL&quot;).Result() &#125; 输出成功结果：10 9 8 7 6 5 4 3 2 1 0 失败例:1rds.SetNX(&quot;aatestNXTTL&quot;, &quot;x&quot;, time.Duration(totaltime)*time.Second) 输出失败结果： 10 0 0 0 0 0 。。。。 ** 在 time.Duration(totaltime)中，totaltime默认的是 ns 纳秒。若输入rds.SetNX(&quot;aatestNXTTL&quot;, &quot;x&quot;, time.Duration(totaltime)) 如果反应快的话直接输出 ttl，不 /1e9转化成秒 ，可能会输出 10ns 。有时候反应慢了，就直接输出 0。 创建redis-client 对象12345client := redis.NewClient(&amp;redis.Options&#123; Addr: &quot;localhost:6379&quot;, //地址：端口 Password: &quot;&quot;, //密码没有可不填 DB: 0, //库号 &#125;) 返回值12set 成功返回 &quot;OK&quot; 失败返回 &quot;ERR syntax error&quot;hset 成功返回 &quot;1&quot; 失败返回 &quot;err&quot; redis简单操作1hmset 可以实现 n次 hset的操作 get存取值判断 Get() 取值 判断是否为空 val == “” 用空串比较123456789redis 存到期时间的值 id := &quot;4001025061&quot; rc.SetNX(id, &quot;1&quot;, 10*time.Second) // key value timeout times2, err := rc.Get(id).Result() if err != nil &#123; fmt.Println(err) &#125; if times2 == &quot;&quot; &#123; fmt.Println(&quot;值等于 nil&quot;) &#125;","categories":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://yantao1995.github.io/tags/redis/"},{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"}],"author":"Tany"},{"title":"gorm及gin入门及踩坑日记","slug":"gorm及gin入门的小坑","date":"2019-10-21T14:50:00.000Z","updated":"2019-11-20T13:14:14.342Z","comments":true,"path":"2019/10/21/gorm及gin入门的小坑/","link":"","permalink":"https://yantao1995.github.io/2019/10/21/gorm及gin入门的小坑/","excerpt":"golang的关系型数据库框架gorm 和 web框架gin的一些踩坑实录","text":"golang的关系型数据库框架gorm 和 web框架gin的一些踩坑实录 mysql值映射12enmu类型 对应 stringint 类型在mysql中的int长度为最大16位。 update更新 where() 函数应放在 update()函数之前,否则无法完成where的字句查询 。 在Update(column,value) 中value与column的类型需要相对应。非对应类型：比如本应填整型的地方，如果填写了”2”，则会自动映射成ASCII值50。 gorm结构体映射及json构造映射 1234type GormAndJSON struct&#123; UID int `gorm:&quot;cloumn:uid&quot; json:&quot;uid&quot;` Date time.Time `gorm:&quot;column:date&quot; json:&quot;date&quot;`&#125; 结构体字段名 UID 和 Date 首字母一定要大写。大写类似java的public，小写类似private。小写无法完成gorm的cloumn字段映射，也不能json.Marshal，json.Unmarshal映射 mysql数据库的 datetime 字段，在结构体中定义类型为 time.Time 的可以接收。 gorm映射时gorm:&quot;column:date&quot; 不加column有时会导致某些字段无法正确映射，int类型字段可以映射，但string，datetime等字段无法完成映射。 gin接收 GET 请求的参数 12345r := gin.Default() r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; param1 := c.GetString(&quot;param1&quot;) param2 := c.Query(&quot;param2&quot;) &#125;) 此时的param1为空值 “” 此时的param2能正常获取到参数 gin接收POST请求参数123c := *gin.Contextname := c.PostForm(&quot;name&quot;)message := c.GetString(&quot;message&quot;) 此时的name能正常获取到参数 此时的message为空值”” gin设置头部 返回内容为json123c := *gin.Contextc.Set(&quot;content-type&quot;, &quot;application/json&quot;)无效时使用 c.Header(&quot;content-type&quot;, &quot;application/json&quot;) gorm 更新表的坑123// 警告:当使用struct更新时，FORM将仅更新具有非空值的字段// 对于下面的更新，什么都不会更新为&quot;&quot;，0，false是其类型的空白值db.Model(&amp;user).Updates(User&#123;Name: &quot;&quot;, Age: 0, Actived: false&#125;) gin文件下载1c.File(filepath+filename) gorm 多库联合查询指定库名，比如 demo.test_t1 表名前加库名 gin限制ip登录123456789101112131415ipList := []string&#123; &quot;127.0.0.1&quot;, &quot;localhost&quot;, &#125; flag := false clientIP := c.ClientIP() for _, host := range ipList &#123; if clientIP == host &#123; flag = true &#125; &#125; if !flag &#123; c.String(404, &quot;拒绝访问&quot;) return &#125; 跨库查询是否有特定的行数据存在123456rows, _ := db.Table(&quot; lxg.lxg_shoping_order as lso &quot;).Where(&quot; lso.`status` = &apos;5&apos; and lso.id = ? &quot;, &quot;2&quot;).Rows() if rows.Next() &#123; fmt.Println(&quot;true&quot;) &#125; else &#123; fmt.Println(&quot;false&quot;) &#125; true为存在至少一行，false表示不存在","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"},{"name":"gorm","slug":"gorm","permalink":"https://yantao1995.github.io/tags/gorm/"},{"name":"gin","slug":"gin","permalink":"https://yantao1995.github.io/tags/gin/"}],"author":"Tany"},{"title":"go slice","slug":"hello k8s","date":"2019-09-20T01:38:00.000Z","updated":"2019-09-22T03:23:04.428Z","comments":true,"path":"2019/09/20/hello k8s/","link":"","permalink":"https://yantao1995.github.io/2019/09/20/hello k8s/","excerpt":"切片的结构，创建，扩容","text":"切片的结构，创建，扩容 切片结构12345type slice struct &#123; array unsafe.Pointer len int cap int&#125; Pointer：指向一个数组的指针 len： 代表当前切片的长度 cap ：是当前切片的容量，总是大于等于 len 。 切片创建123//1.类型自动推导s:=[]int&#123;1,2,3,4&#125;fmt.Println(s, len(s), cap(s)) 123//2.借助make函数，格式为：make(切片类型，切片长度，切片容量)s1:=make([]int,5,10)fmt.Println(s1, len(s1), cap(s1)) 1234//3.借助make函数，格式为：make(切片容量，切片长度)s2:=make([]int,5)fmt.Println(s2, len(s2), cap(s2))//这种情况切片容量与切片长度相等 1234//4.通过现成的数组（或者切片）进行创建a:=[5]int&#123;1,2,3,4,5&#125;s3:=a[1:3:5]fmt.Println(s3, len(s3), cap(s3)) 切片扩容扩容出处，简书博主： l_sivan append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。 若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。 以上两个方法得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况capmem，然后再进行capmem向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://yantao1995.github.io/tags/go/"},{"name":"slice","slug":"slice","permalink":"https://yantao1995.github.io/tags/slice/"},{"name":"切片","slug":"切片","permalink":"https://yantao1995.github.io/tags/切片/"}]},{"title":"go + mysql","slug":"hello java","date":"2019-09-12T07:02:00.000Z","updated":"2019-09-22T03:22:43.080Z","comments":true,"path":"2019/09/12/hello java/","link":"","permalink":"https://yantao1995.github.io/2019/09/12/hello java/","excerpt":"go对mysql导入，增删改查。","text":"go对mysql导入，增删改查。 高级编程https://chai2010.gitbooks.io/advanced-go-programming-book/content/ 下载驱动包：$ go get github.com/go-sql-driver/mysql（1）sql.Open(“mysql”, “username:pwd@/databasename”)功能：返回一个DB对象，DB对象对于多个goroutines并发使用是安全的，DB对象内部封装了连接池。 实现：open函数并没有创建连接，它只是验证参数是否合法。然后开启一个单独goroutines去监听是否需要建立新的连接，当有请求建立新连接时就创建新连接。 注意：open函数应该被调用一次，通常是没必要close的。 （2）DB.Exec()功能：执行不返回行（row）的查询，比如INSERT，UPDATE，DELETE 实现：DB交给内部的exec方法负责查询。exec会首先调用DB内部的conn方法从连接池里面获得一个连接。然后检查内部的driver.Conn实现了Execer接口没有，如果实现了该接口，会调用Execer接口的Exec方法执行查询；否则调用Conn接口的Prepare方法负责查询。 （3）DB.Query()功能：用于检索（retrieval），比如SELECT 实现：DB交给内部的query方法负责查询。query首先调用DB内部的conn方法从连接池里面获得一个连接，然后调用内部的queryConn方法负责查询。 （4）DB.QueryRow()功能：用于返回单行的查询 实现：转交给DB.Query()查询 （5）db.Prepare()功能：返回一个Stmt。Stmt对象可以执行Exec,Query,QueryRow等操作。 实现：DB交给内部的prepare方法负责查询。prepare首先调用DB内部的conn方法从连接池里面获得一个连接，然后调用driverConn的prepareLocked方法负责查询。 Stmt相关方法： 1234st.Exec()st.Query()st.QueryRow()st.Close() （6）db.Begin()功能：开启事务，返回Tx对象。调用该方法后，这个TX就和指定的连接绑定在一起了。一旦事务提交或者回滚，该事务绑定的连接就还给DB的连接池。 实现：DB交给内部的begin方法负责处理。begin首先调用DB内部的conn方法从连接池里面获得一个连接，然后调用Conn接口的Begin方法获得一个TX。 TX相关方法： //内部执行流程和上面那些差不多，只是没有先去获取连接的一步，因为这些操作是和TX关联的，Tx建立的时候就和一个连接绑定了，所以这些操作内部共用一个TX内部的连接。 123456tx.Exec() tx.Query()tx.QueryRow()tx.Prepare()tx.Commit()tx.Rollback() tx.Stmt()//用于将一个已存在的statement和tx绑定在一起。一个statement可以不和tx关联，比如db.Prepare()返回的statement就没有和TX关联。","categories":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://yantao1995.github.io/tags/golang/"},{"name":"orm","slug":"orm","permalink":"https://yantao1995.github.io/tags/orm/"},{"name":"mysql","slug":"mysql","permalink":"https://yantao1995.github.io/tags/mysql/"}],"author":"Tany"},{"title":"clair镜像扫描","slug":"clair镜像扫描","date":"2019-08-19T10:00:00.000Z","updated":"2019-09-22T03:21:40.766Z","comments":true,"path":"2019/08/19/clair镜像扫描/","link":"","permalink":"https://yantao1995.github.io/2019/08/19/clair镜像扫描/","excerpt":"clair简介，docker镜像简介，准备工作","text":"clair简介，docker镜像简介，准备工作 cliar简介Clair是一个开源工具，用于扫描Docker镜像的漏洞。 Clair没有Web端，也没有命令行工具。只能通过REST API或第三方CLI工具。 获取clair镜像：docker pull quay.io/coreos/clair 镜像简介docker镜像由 1+n层组成，每一层都是tar文件块存储在docker注册表里。 需要的工具 clair REST API服务 CVE Updater 更新漏洞数据库 CVE 数据源列表 postgreSQL 数据库 存储漏洞信息 上传docker镜像分析结果 cliar：api_v1官方文档 接口 POST/layers 将docker镜像层推送到Clair进行分析 GET/layers/:name 获取已发现漏洞的Docker镜像层的信息 k8s集群内配置文件 clair_config/config.yaml docker-compose.yaml (docker-compose up/down) 参考：Static Analysis of Docker image vulnerabilities with Clair","categories":[{"name":"k8s","slug":"k8s","permalink":"https://yantao1995.github.io/categories/k8s/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://yantao1995.github.io/tags/k8s/"},{"name":"clair","slug":"clair","permalink":"https://yantao1995.github.io/tags/clair/"},{"name":"镜像扫描","slug":"镜像扫描","permalink":"https://yantao1995.github.io/tags/镜像扫描/"},{"name":"docker","slug":"docker","permalink":"https://yantao1995.github.io/tags/docker/"}],"author":"Tany"},{"title":"java相关的技术经验汇总","slug":"hello-world","date":"2019-08-13T01:03:00.000Z","updated":"2019-09-22T03:20:20.757Z","comments":true,"path":"2019/08/13/hello-world/","link":"","permalink":"https://yantao1995.github.io/2019/08/13/hello-world/","excerpt":"java的一些基础知识汇总","text":"java的一些基础知识汇总 SpringMVChttps://blog.csdn.net/joker_honey/article/details/80920730 单例 single 构造函数私有化，一个公有的函数获取和创建…。或者使用枚举 Enum 反射 ：得到元数据的行为。ClassgetPackage();getSuperClass();getMethod();...... 序列化:ObjectInputStream ; ObjectOutputStream IoC:控制反转使用反射机制并结合属性配置文件的工厂模式。去构建依赖对象(Factory生产。任意多子类，工厂类不需要修改)由Ioc容器来控制对象的创建及注入依赖对象 AOP：切面：多个模块拥有同一种功能。(横切)动态代理 ：（静态代理：《使用了聚合：让代理类持有一个委托类的引用》一个类中有另一个类的对象。（也可以继承实现，但是继承很不灵活）） public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException参数1：类加载器，指明哪个类的被代理。参数2：需要实现的《接口类》的Class数组（因为是数组，所有可以有多个）参数3：调用处理方法。调用对象时，做什么。函数的参数。 动态代理详细剖析： http://developer.51cto.com/art/201606/512434.htm 消息 http://www.importnew.com/21875.html 分布式并发http://ifeve.com/java-concurrency-thread-directory/ 分布式集群高并发详细：https://blog.csdn.net/u011277123/article/details/54015614 多线程继承Thread类 或者 实现 Runnable接口。 Runnable可以实现数据共享 队列Queue接口与List、Set同一级别，都是继承了Collection接口。 NIO 与 IO：IO： 面向流 单向的 面向缓冲区：通道可以是单双向的 阻塞IONIO：面向缓冲区(Buffer Oriented)：通道可以是单向的，也可以是双向的非阻塞IO(Non Blocking IO)缓冲区(存储)和管道(数据源和结点的连接传输Buffer) PrintWriter文本文件 处理字符流，一次写入2个字节， PrintStream处理字节流，一次写入一个字节","categories":[{"name":"java","slug":"java","permalink":"https://yantao1995.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yantao1995.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yantao1995.github.io/tags/spring/"},{"name":"并发","slug":"并发","permalink":"https://yantao1995.github.io/tags/并发/"}],"author":"Tany"}]}