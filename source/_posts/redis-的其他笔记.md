title: redis 的其他笔记
author: Tany
tags:
  - redis
categories:
  - redis
date: 2020-11-20 19:20:00
---
阅读redis书籍《redis设计与实现》笔记。
源码版本redis 3.0。


<!-- more -->

## 一些基本概念

### Redis的高并发和快速原因

1. redis是基于内存的，内存的读写速度非常快；
2. redis是单线程的，省去了很多上下文切换线程的时间；
3. redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

### Object对象 （每一个键和值都是一个对象）

- redisObject结构

```
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    int refcount;

    // 指向实际值的指针
    void *ptr;

} robj;
```

#### refcount引用计数(内存回收&对象共享)

1. 内存回收

   - 在创建一个新对象时，引用计数的值被初始化为1
   - 当对象被一个新程序使用时，它的引用计数值会加1
   - 当对象不再被一个程序使用时，它的引用计数会减1
   - 当对象的引用计数变成0时，所占用的内存会被释放。
2. 对象共享：多个键共享同一个值对象（3.0版本 0-9999整数值）

   - 将键的值指针指向一个现有的值对象
   - 该值对象的引用计数加1

#### lru空转时长

- 该属性记录了对象最后一次被命令程序访问的时间
- object idletime 命令会降现在的时间减去lru得到空转时长
- 空转时长较高的部分键会优先被服务器释放，从而回收内存

### 5大数据类型

| 字段   | 底层实现                                                                                                                                                                                                                                         |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| string | 1. sds 简单动态字符串(编码为：raw[此时内存结构与SDS结构一致，内存分配次数为两次，创建redisObject对象和sdshdr结构]或者embstr[内存结构做了优化，用于保存顿消的字符串；内存分配也只需要一次就可完成，分配一块连续的空间即可])，2. 直接存储(编码int) |
| hash   | 1. hashtable 字典+哈希表+哈希节点,2 ziplist 压缩列表                                                                                                                                                                                             |
| list   | 1. adlist 双向链表，2. 压缩列表                                                                                                                                                                                                                  |
| set    | 1. intset整数集合,hashtable 哈希表  类似java的hashset                                                                                                                                                                                            |
| zset   | 1. 压缩列表,2. skiplist 字典+跳跃表                                                                                                                                                                                                              |

#### string (int,embstr,raw)

- int： 整数值
- embstr: 简单动态字符串（最直观的区别：value短(小于32字节)，一次内存分配包含redisObject结构和sdshdr结构，空间连续）
- raw：简单动态字符串（最直观的区别：value长(大于32字节)，两次内存分配分别创建redisObject结构和sdshdr结构）

1. 在Redis中，存储long、double类型的浮点数是先转换为字符串再进行存储的。
2. raw与embstr编码效果是相同的，不同在于内存分配与释放，raw两次，embstr一次。
3. embstr内存块连续，能更好的利用缓存在来的优势
4. int编码和embstr编码如果做追加字符串等操作，满足条件下会被转换为raw编码；embstr编码的对象是只读的，一旦修改会先转码到raw。

#### list

- ziplist：压缩列表
- adlist：双端链表（linkedlist）

1. 列表对象使用ziplist编码需要满足两个条件：一是所有字符串长度都小于64字节，二是元素数量小于512，不满足任意一个都会使用linkedlist编码。
2. 两个条件的数字可以在Redis的配置文件中修改，list-max-ziplist-value选项和list-max-ziplist-entries选项。
3. adlist双端链表*ptr指向的链表内元素就是string的字符串对象，字符串对象是唯一个在五大对象中作为嵌套对象使用的。

#### hash

- ziplist：压缩列表
- ht：使用字典实现哈希对象hashtable

1. 哈希对象使用ziplist编码需要满足两个条件：一是所有键值对的键和值的字符串长度都小于64字节；二是键值对数量小于512个；不满足任意一个都使用hashtable编码。
2. 以上两个条件可以在Reids配置文件中修改hash-max-ziplist-value选项和hash-max-ziplist-entries选项。

#### set

- intset:整数集合
- ht：字典实现的集合对象hashtable

1. 集合对象使用intset编码需要满足两个条件：一是所有元素都是整数值；二是元素个数小于等于512个；不满足任意一条都将使用hashtable编码。
2. 以上第二个条件可以在Redis配置文件中修改set-max-intset-entries选项。

#### zset

- ziplist：压缩列表
- skiplist:跳跃表+字典实现有序集合对象
  * [单使用字典也可以实现,但因为无序，尽管虽然查找O(1),却在排序时浪费空间O(n)来存储结果。]
  * [单使用跳跃表也可以实现，虽然有序了，但是根据成员查找分值将会从O(1)上升到O(logN)]

1. 跳跃表优点是有序，但是查询分值复杂度为O(logn)；字典查询分值复杂度为O(1) ，但是无序，所以结合连个结构的有点进行实现。
2. 虽然采用两个结构但是集合的元素成员和分值是共享的，两种结构通过指针指向同一地址，不会浪费内存。
3. 有序集合对象使用ziplist编码需要满足两个条件：一是所有元素长度小于64字节；二是元素个数小于128个；不满足任意一条件将使用skiplist编码。
4. 以上两个条件(3中)可以在Redis配置文件中修改zset-max-ziplist-entries选项和zset-max-ziplist-value选项。

- ***列表（list）、哈希（hash）、集合（set）、有序集合（zset）底层实现都用到了压缩列表结构，并且使用压缩列表结构的条件都是在元素个数比较少、字节长度较短的情况下***

### expire/pexpire 过期键

#### 最终过期命令的转换

- 最终都变成pexpireat

1. expire -> pexpire  -> pexpireat
2. expireat -> pexpireat

#### expire 指向一个维护键过期时间的 dict字典

- 字典中key为键的名称，value为long long类型的 毫秒精度的Unix时间戳

#### 移除过期时间 persist

- 删除expire指向的dict字典内的key

#### 过期键删除策略

1. 定时删除：设置过期键的同时，创建一个定时器timer，过期就立即删除。
2. 惰性删除：过期了也不管，获取时检查是否过期，过期就删。
3. 定期删除：每隔一段时间，对库检查并删除过期键。

- 定时删除：cpu负载加大，内存得到很好释放
- 惰性删除：对cpu友好，但是对内存不友好
- 定期删除：介于二者之间，但是间隔得根据实际情况合理设置

#### 备份载入

##### RDB载入

- 主服务器模式：过期键不载入
- 服务器模式：无论是否过期，都载入

##### AOF

1. 载入

- 键过期但还未删除时，AOF文件不会因为过期而影响。
- 当删除触发时，程序会向AOF文件追加一条del命令，显式删除

2. 重写

- 重写过程会检查，过期的键不会保存。

#### 主从复制

- 由主服务器来控制从服务器统一的删除过期键

1. 主服务器删除过期键之后，显式的向所有从服务器发送del命令。
2. 从服务器在未接收到主服务器发来的del命令前，即便是过期了也不会删除，继续像未过期一样处理。
3. 接收到del命令之后，才会删除过期键。

### RDB

- save: 停止服务来进行备份
- bgsave：fork一个子进程来进行备份

### AOF

#### 创建

1. 命令追加append
2. 文件写入
3. 文件同步

#### 重写rewrite

- 创建一个新的AOF，来代替原来的AOF文件，将冗余命令去掉。（多条命令合并成一条）
- 后台重写，为了保证主进程仍然能处理请求，设置AOF重写缓冲区，为了保证数据一致。
  写命令会同时发送给AOF缓冲区和AOF重写缓冲区。
  1. 执行客户端发来的命令。
  2. 将执行后的写命令追加到AOF缓冲区。
  3. 将执行后的写命令追加到AOF重写缓冲区。
  
  
## 主从复制

### 旧版复制(同步,命令传播)

- 缺陷：
  1. 初次复制：正常完成。
  2. 断线后重复制：也能正常完成，但是效率非常低。
     比如：断线这段时间只有几条数据没复制，但是主服务器生成的RDB文件却包含
     了之前已经完成复制了的数据。重复发送了很多冗余数据。

#### 同步

1. 从服务器向主服务器发送sync命令。
2. 收到sync命令的主服务器执行bgsave命令，在后台生成一个RDB文件，并
   使用一个缓冲区记录从现在开始执行的所有写命令。
3. 当主服务器的bgsave命令执行完毕后，主服务器会降bgsave命令生成
   RDB文件发送给从服务器。从服务器收到并载入，更新自己状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行，更新自己状态。

#### 命令传播

1. 同步完成后，如果主服务器执行写命令后，主从服务器状态不一致了。
2. 主服务器执行完后，命令会发送给从服务器执行，保持状态一致。

### 新版主从复制(2.8版本之后（psync代替了sync）)

- 两种同步机制：

  1. 完整重同步：初次复制的情况，发送完整的RDB文件。
  2. 部分重同步：处理断线后重连。
- ***部分重同步*** ：

  1. 断线连接后：从服务器发送psync命令给主服务器
  2. 主服务器回复+continue回复，表示执行部分重同步
  3. 从服务器接收+continue回复，准备执行部分重同步
  4. 主服务器发送待同步数据

#### psync细节：

- 3个部分：

1. 主从服务器的复制偏移量
2. 主服务器的复制积压缓冲区
3. 服务器的运行id

##### 复制偏移量

- 主从服务器都会维护一个复制偏移量：

1. 主服务器每次向从服务器传播n个字节的数据时，就将自己的复制偏移量的值加上n。
2. 从服务器每次收到主服务器传播来的n个字节的数据时，就将自己的复制偏移量加上n。

##### 复制积压缓冲区

- 主服务器维护的一个固定长度先进先出的队列，默认1MB大小。
- 当从服务器重连后：通过psync命令将自己的复制偏移量offset发送给主服务器

1. 如果offset之后的数据，仍然在复制积压缓冲区里，就执行部分重同步
2. 如果不在，就执行完整重同步

##### 服务器运行id

- 每个主从服务器都有自己的运行id
- 启动时自动生成，由40个随机的16进制字符组成。

***用于同步时的相互识别***

### 复制的实现

- 步骤：

1. 设置主服务器的地址和端口
2. 建立套接字socket连接
3. 发送ping命令
4. 身份验证
5. 发送端口信息
6. 同步
7. 命令传播

## 高可用

### Sentinel哨兵（高可用解决方案）

- 一个或多个sentinel实例组成的系统可以监控任意个主从服务器，并在
  被监视的主服务器下线时，自动将其属下的某个从服务器提升为主服务器。

  1. 主服务器下线时，挑选其属下的一个从服务器，设置为新的主服务器。
  2. sentinel系统向原主服务器属下的所有其他从服务器发送新的复制指令，
     让他们成为新主服务器的从服务器。
  3. 当已下线的原主服务器重新上线时，sentinel系统会将它设置成新主服务器的从服务器。
- sentinel本质是一个运行在特殊模式下的redis服务器，初始化时不加载RDB或者AOF文件



## 常见缓存解决方案


#### 缓存穿透

- 描述：

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

- 解决方案：

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
3. 布隆过滤器：先将存在的数据存入布隆过滤器，进行首次的过滤，若布隆过滤器中不存在则直接返回NULL

#### 缓存击穿

- 描述：

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

- 解决方案：

1. 设置热点数据永远不过期。
2. ***加互斥锁:***
   - 缓存中有数据，直接返回结果了
   - 缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。
   - 当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。

#### 缓存雪崩

- 描述：

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

- 解决方案：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3. 设置热点数据永远不过期。